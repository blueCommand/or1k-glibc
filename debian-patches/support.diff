Description: Or1k support
 TODO: Put a short summary on the line above and replace this paragraph
 with a longer explanation of this change. Complete the meta-information
 with other relevant fields (see below for details). To make it easier, the
 information below has been extracted from the changelog. Adjust it or drop
 it.
 .
 eglibc (2.18-0experimental1) experimental; urgency=low
 .
   [ Adam ConradÂ ]
   * debian/patches/i386/cvs-nonascii-case-strcmp.diff: Pull upstream patch
     to fix LC_CTYPE nonascii-case fallback in i686 strcasecmp/strncasecmp.
   * debian/testsuite-checking/*: Update 686 targets to match the 586 ones.
   * Generate expected-results-powerpc64le-linux-gnu-libc for ppc64el port.
   * debian/testsuite-checking/*: Normalize expected results for ARM ports.
   * debian/patches/i386/cvs-sse42-strstr*: Backport upstream commits which
     drop buggy SSE4.2 srtstr implementations in favour of an SSE2 version.
   * debian/patches/any/cvs-ptrace_peeksiginfo_args.diff: Prepend __ prefix
     to ptrace_peeksiginfo_args struct to prevent namespace clash w/ linux.
   * debian/patches/powerpc/cvs-ppc64-vdso-ifunc.diff: Pull upstream fix to
     squash undefined behaviour in PowerPC64 vDSO IFUNC symbol resolutions.
   * debian/patches/powerpc/submitted-gettimeofday-vdso.diff: New diff from
     Adhemerval Zanella at IBM to fix gettimeofday vDSO/IFUNC interactions.
   * debian/patches/powerpc/submitted-gettimeofday-32.diff: Pull patch from
     Adhemerval Zanella at IBM to fix 32-bit gettimeofday VSYSCALL lookups.
   * debian/rules.d/build.mk, debian/sysdeps/{hurd,linux,kfreebsd}.mk: Make
     pt_chown keyed off a new variable that we can use to enable or disable
     it per kernel type rather than just the primary libc (Closes: #734607)
   * debian/patches/kfreebsd/submitted-waitid.diff: On Linux, we must undef
     waitflags before we define them or we'll conflict with kernel headers.
 .
   [ Aurelien Jarno ]
   * debian/patches/any/cvs-vfscanf-0e+0.diff: new patch from upstream to
     fix parsing of 0e+0.  Closes: #732993.
   * debian/patches/mips/submitted-wordsize-clang.diff: drop now that clang
     correctly defines_MIPS_SZPTR.
 .
   [ Samuel Thibault ]
   * patches/hurd-i386/tg-nfds-poll.diff: New patch to fix poll call with big
     array.
   * patches/hurd-i386/tg-sigstate_locking.diff: New patch to fix sigstate
     creation.
   * patches/hurd-i386/tg-sigstate_thread_reference.diff: New patch to fix
     sigstate thread reference counting.
   * patches/hurd-i386/{libpthreadlibpthread_stubs,libpthread_hurd_cond_wait,
     submitted-libpthread-elf,cvs-libpthread_lock,libpthread_cancellation,
     libpthread_hurd_cond_timedwait,libpthread_ctypes,cvs-pthread_atfork,
     cvs-tls-threadvar-threadself,cvs-libpthread-tls,
     cvs-libpthread-userstack}.diff: Remove, replaced by...
   * patches/hurd-i386/cvs-libpthread.diff: ... this git snapshot, and...
   * patches/hurd-i386/libpthread_build.diff: ... these build fixes.
   * patches/hurd-i386/tg-aio_misc.diff: New patch to fix aio build.
   * control.d/main: Build-depend on newer gnumach-dev to get
     thread_terminate_release RPC.
   * libc0.3.symbols.hurd-i386: Add thread_terminate_release.
Author: Adam Conrad <adconrad@0c3.net>
Bug-Debian: http://bugs.debian.org/732993
Bug-Debian: http://bugs.debian.org/734607

---
The information above should follow the Patch Tagging Guidelines, please
checkout http://dep.debian.net/deps/dep3/ to learn about the format. Here
are templates for supplementary fields that you might want to add:

Origin: <vendor|upstream|other>, <url of original patch>
Bug: <url in upstream bugtracker>
Bug-Debian: http://bugs.debian.org/<bugnumber>
Bug-Ubuntu: https://launchpad.net/bugs/<bugnumber>
Forwarded: <no|not-needed|url proving that it has been forwarded>
Reviewed-By: <name and email of someone who approved the patch>
Last-Update: <YYYY-MM-DD>

--- eglibc-2.18.orig/elf/elf.h
+++ eglibc-2.18/elf/elf.h
@@ -3269,6 +3269,42 @@ typedef Elf32_Addr Elf32_Conflict;
 
 #define R_TILEGX_NUM		130
 
+/* OpenRISC 1000 specific relocs */
+#define R_OR1K_NONE            0
+#define R_OR1K_32              1
+#define R_OR1K_16              2
+#define R_OR1K_8               3
+#define R_OR1K_LO_16_IN_INSN   4
+#define R_OR1K_HI_16_IN_INSN   5
+#define R_OR1K_INSN_REL_26     6
+#define R_OR1K_GNU_VTENTRY     7
+#define R_OR1K_GNU_VTINHERIT   8
+#define R_OR1K_32_PCREL                9
+#define R_OR1K_16_PCREL                10
+#define R_OR1K_8_PCREL         11
+#define R_OR1K_GOTPC_HI16      12
+#define R_OR1K_GOTPC_LO16      13
+#define R_OR1K_GOT16           14
+#define R_OR1K_PLT26           15
+#define R_OR1K_GOTOFF_HI16     16
+#define R_OR1K_GOTOFF_LO16     17
+#define R_OR1K_COPY            18
+#define R_OR1K_GLOB_DAT                19
+#define R_OR1K_JMP_SLOT                20
+#define R_OR1K_RELATIVE                21
+#define R_OR1K_TLS_GD_HI16     22
+#define R_OR1K_TLS_GD_LO16     23
+#define R_OR1K_TLS_LDM_HI16    24
+#define R_OR1K_TLS_LDM_LO16    25
+#define R_OR1K_TLS_LDO_HI16    26
+#define R_OR1K_TLS_LDO_LO16    27
+#define R_OR1K_TLS_IE_HI16     28
+#define R_OR1K_TLS_IE_LO16     29
+#define R_OR1K_TLS_LE_HI16     30
+#define R_OR1K_TLS_LE_LO16     31
+#define R_OR1K_TLS_TPOFF       32
+#define R_OR1K_TLS_DTPOFF      33
+#define R_OR1K_TLS_DTPMOD      34
 
 __END_DECLS
 
--- /dev/null
+++ eglibc-2.18/ports/sysdeps/unix/sysv/linux/or1k/sysdep.c
@@ -0,0 +1,33 @@
+/* Copyright (C) 2011, 2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <sysdep.h>
+#include <errno.h>
+
+long __syscall_error (long err);
+hidden_proto (__syscall_error)
+
+/* This routine is jumped to by all the syscall handlers, to stash
+   an error number into errno.  */
+long
+__syscall_error (long err)
+{
+  __set_errno (- err);
+  return -1;
+}
+hidden_def (__syscall_error)
--- /dev/null
+++ eglibc-2.18/ports/sysdeps/unix/sysv/linux/or1k/clone.c
@@ -0,0 +1,58 @@
+/* Copyright (C) 1998, 2002, 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <stdarg.h>
+#include <sysdep.h>
+
+extern int __or1k_clone (int (*fn)(void *), void *child_stack,
+			 int flags, void *arg, pid_t *ptid,
+			 void *tls, pid_t *ctid);
+
+
+/* or1k ABI uses stack for varargs, syscall uses registers.
+ * This function moves from varargs to regs. */
+int
+__clone (int (*fn)(void *), void *child_stack,
+	 int flags, void *arg, ...
+	 /* pid_t *ptid, struct user_desc *tls, pid_t *ctid */ )
+{
+  void *ptid;
+  void *tls;
+  void *ctid;
+  va_list ap;
+  int err;
+
+  va_start (ap, arg);
+  ptid = va_arg (ap, void *);
+  tls = va_arg (ap, void *);
+  ctid = va_arg (ap, void *);
+  va_end (ap);
+
+  /* Sanity check the arguments */
+  err = -EINVAL;
+  if (!fn)
+    goto syscall_error;
+  if (!child_stack)
+    goto syscall_error;
+
+  return __or1k_clone (fn, child_stack, flags, arg, ptid, tls, ctid);
+
+syscall_error:
+  __set_errno (-err);
+  return -1;
+}
+weak_alias (__clone, clone)
--- /dev/null
+++ eglibc-2.18/ports/sysdeps/unix/sysv/linux/or1k/prctl.c
@@ -0,0 +1,41 @@
+/* Copyright (C) 1995-1998,2000,2003,2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <stdarg.h>
+#include <sysdep.h>
+
+/* or1k ABI uses stack for varargs, syscall uses registers.
+ * This function moves from varargs to regs. */
+int
+__prctl (int __option, ...)
+{
+  va_list ap;
+  unsigned long arg2;
+  unsigned long arg3;
+  unsigned long arg4;
+  unsigned long arg5;
+
+  va_start (ap, __option);
+  arg2 = va_arg (ap, unsigned long);
+  arg3 = va_arg (ap, unsigned long);
+  arg4 = va_arg (ap, unsigned long);
+  arg5 = va_arg (ap, unsigned long);
+  va_end (ap);
+
+  return INLINE_SYSCALL (prctl, 5, __option, arg2, arg3, arg4, arg5);
+}
+weak_alias (__prctl, prctl)
--- /dev/null
+++ eglibc-2.18/ports/sysdeps/unix/sysv/linux/or1k/sysdep.h
@@ -0,0 +1,212 @@
+/* Copyright (C) 2011 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <asm/unistd.h>
+#include <sysdeps/or1k/sysdep.h>
+#include <sysdeps/unix/sysv/linux/generic/sysdep.h>
+#include <sys/syscall.h>
+
+#undef SYS_ify
+#define SYS_ify(syscall_name)	(__NR_##syscall_name)
+
+/* Or1k uses 0x2000 as page size */
+#define MMAP_PAGE_SHIFT 13
+
+/* Linux uses a negative return value to indicate syscall errors,
+   unlike most Unices, which use the condition codes' carry flag.
+
+   Since version 2.1 the return value of a system call might be
+   negative even if the call succeeded.  E.g., the `lseek' system call
+   might return a large offset.  Therefore we must not anymore test
+   for < 0, but test for a real error by making sure the value in R0
+   is a real error number.  Linus said he will make sure the no syscall
+   returns a value in -1 .. -4095 as a valid result so we can safely
+   test with -4095.  */
+
+#ifdef __ASSEMBLER__
+
+/* Macros used in syscall-template.S */
+#define ret          l.jr r9; l.nop
+#define ret_NOERRNO  l.jr r9; l.nop
+
+#undef DO_CALL
+#define DO_CALL(syscall_name) \
+    l.addi r11, r0, SYS_ify (syscall_name); \
+    l.sys 1; \
+    l.nop
+
+#define PSEUDO(name, syscall_name, args) \
+  ENTRY (name); \
+  DO_CALL(syscall_name); \
+  /* if -4096 < ret < 0 holds, it's an error */ \
+  l.sfgeui r11, 0xf001; \
+  l.bf 0f; \
+  l.nop
+
+#define PSEUDO_NOERRNO(name, syscall_name, args)  \
+  ENTRY (name);           \
+  DO_CALL(syscall_name)
+
+#define PSEUDO_END(name) \
+0: \
+  l.j SYSCALL_ERROR_NAME; \
+  l.ori r3,r11,0; \
+  END (name)
+
+#define PSEUDO_END_NOERRNO(name) \
+  END (name)
+
+#ifndef PIC
+/* For static code, on error jump to __syscall_error directly. */
+# define SYSCALL_ERROR_NAME __syscall_error
+#elif NOT_IN_libc
+/* Use the internal name for libc/libpthread shared objects. */
+# define SYSCALL_ERROR_NAME __GI___syscall_error
+#else
+/* Otherwise, on error do a full PLT jump. */
+# define SYSCALL_ERROR_NAME plt(__syscall_error)
+#endif
+
+#else /* not __ASSEMBLER__ */
+
+#include <errno.h>
+
+/* Pointer mangling is not yet supported for or1k.
+ * TODO: Implement pointer guards */
+#define PTR_MANGLE(var) (void) (var)
+#define PTR_DEMANGLE(var) (void) (var)
+
+#undef INLINE_SYSCALL
+#define INLINE_SYSCALL(name, nr, args...) \
+	({									\
+	 unsigned int resultvar = INTERNAL_SYSCALL (name, , nr, args);		\
+	 if (__builtin_expect (INTERNAL_SYSCALL_ERROR_P (resultvar, ), 0))	\
+	   {									\
+	     __set_errno (INTERNAL_SYSCALL_ERRNO (resultvar, ));		\
+	     resultvar = 0xffffffff;						\
+	   }									\
+	 (int) resultvar; })
+
+#undef INTERNAL_SYSCALL
+#define INTERNAL_SYSCALL(name, err, nr, args...) \
+	({ unsigned long __sys_result;						\
+	  {									\
+	    register long __sc_ret __asm__ ("r11") = SYS_ify (name);		\
+	    LOAD_ARGS_##nr (args)						\
+	    __asm__ __volatile__ ("l.sys     1"					\
+					   : "=r" (__sc_ret) ASM_ARGS_OUT_##nr	\
+					   : "0" (__sc_ret) ASM_ARGS_IN_##nr	\
+			 : ASM_CLOBBERS_##nr					\
+			   "r12", "r13", "r15", "r17", "r19",			\
+			   "r21", "r23", "r25", "r27", "r29",			\
+			   "r31", "memory");					\
+	    __asm__ __volatile__ ("l.nop");					\
+	    __sys_result = __sc_ret;						\
+	  }									\
+	  (long) __sys_result; })
+
+/* The _NCS variant allows non-constant syscall numbers.  */
+#undef INTERNAL_SYSCALL_NCS
+#define INTERNAL_SYSCALL_NCS(name, err, nr, args...) \
+	({ unsigned long __sys_result;						\
+	  {									\
+	    register long __sc_ret __asm__ ("r11") = name;			\
+	    LOAD_ARGS_##nr (args)						\
+	    __asm__ __volatile__ ("l.sys     1"					\
+					   : "=r" (__sc_ret) ASM_ARGS_OUT_##nr	\
+					   : "0" (__sc_ret) ASM_ARGS_IN_##nr	\
+			 : ASM_CLOBBERS_##nr					\
+			   "r12", "r13", "r15", "r17", "r19",			\
+			   "r21", "r23", "r25", "r27", "r29",			\
+			   "r31", "memory");					\
+	    __asm__ __volatile__ ("l.nop");					\
+	    __sys_result = __sc_ret;						\
+	  }									\
+	  (long) __sys_result; })
+
+/* INTERNAL_SYSCALL_DECL - Allows us to setup some function static
+   value to use within the context of the syscall.
+
+   We do not use it */
+#undef INTERNAL_SYSCALL_DECL
+#define INTERNAL_SYSCALL_DECL(err) do { } while (0)
+
+/* INTERNAL_SYSCALL_ERROR_P - Returns 0 if it wasn't an error, 1 otherwise
+   You are allowed to use the syscall result (val) and the DECL error
+   variable to determine what went wrong. */
+#undef INTERNAL_SYSCALL_ERROR_P
+#define INTERNAL_SYSCALL_ERROR_P(val, err) \
+    ((unsigned int) (val) >= 0xfffff001u)
+
+
+/* INTERLAL_SYSCALL_ERRNO - Munges the val/err pair into the error number.
+   In our case we just flip the sign. */
+#undef INTERNAL_SYSCALL_ERRNO
+#define INTERNAL_SYSCALL_ERRNO(val, err)        (-(val))
+
+/* From here on we have nested macros that generate code for
+ * storing arguments to the syscall */
+
+#define LOAD_ARGS_0()
+
+#define ASM_ARGS_OUT_0
+#define ASM_ARGS_IN_0
+#define ASM_CLOBBERS_0  "r3", ASM_CLOBBERS_1
+
+#define LOAD_ARGS_1(a)        \
+    LOAD_ARGS_0 ()        \
+  register long __a __asm__ ("r3") = (long)(a);
+#define ASM_ARGS_OUT_1  ASM_ARGS_OUT_0, "=r" (__a)
+#define ASM_ARGS_IN_1 ASM_ARGS_IN_0, "1" (__a)
+#define ASM_CLOBBERS_1  "r4", ASM_CLOBBERS_2
+
+#define LOAD_ARGS_2(a, b)     \
+    LOAD_ARGS_1 (a)       \
+  register long __b __asm__ ("r4") = (long)(b);
+#define ASM_ARGS_OUT_2  ASM_ARGS_OUT_1, "=r" (__b)
+#define ASM_ARGS_IN_2 ASM_ARGS_IN_1, "2" (__b)
+#define ASM_CLOBBERS_2  "r5", ASM_CLOBBERS_3
+
+#define LOAD_ARGS_3(a, b, c)      \
+    LOAD_ARGS_2 (a, b)        \
+  register long __c __asm__ ("r5") = (long)(c);
+#define ASM_ARGS_OUT_3  ASM_ARGS_OUT_2, "=r" (__c)
+#define ASM_ARGS_IN_3 ASM_ARGS_IN_2, "3" (__c)
+#define ASM_CLOBBERS_3  "r6", ASM_CLOBBERS_4
+
+#define LOAD_ARGS_4(a, b, c, d)     \
+    LOAD_ARGS_3 (a, b, c)       \
+  register long __d __asm__ ("r6") = (long)(d);
+#define ASM_ARGS_OUT_4  ASM_ARGS_OUT_3, "=r" (__d)
+#define ASM_ARGS_IN_4 ASM_ARGS_IN_3, "4" (__d)
+#define ASM_CLOBBERS_4  "r7", ASM_CLOBBERS_5
+
+#define LOAD_ARGS_5(a, b, c, d, e)    \
+    LOAD_ARGS_4 (a, b, c, d)      \
+  register long __e __asm__ ("r7") = (long)(e);
+#define ASM_ARGS_OUT_5  ASM_ARGS_OUT_4, "=r" (__e)
+#define ASM_ARGS_IN_5 ASM_ARGS_IN_4, "5" (__e)
+#define ASM_CLOBBERS_5  "r8", ASM_CLOBBERS_6
+
+#define LOAD_ARGS_6(a, b, c, d, e, f)   \
+    LOAD_ARGS_5 (a, b, c, d, e)     \
+  register long __f __asm__ ("r8") = (long)(f);
+#define ASM_ARGS_OUT_6  ASM_ARGS_OUT_5, "=r" (__f)
+#define ASM_ARGS_IN_6 ASM_ARGS_IN_5, "6" (__f)
+#define ASM_CLOBBERS_6
+
+#endif
--- /dev/null
+++ eglibc-2.18/ports/sysdeps/unix/sysv/linux/or1k/Makefile
@@ -0,0 +1,8 @@
+ifeq ($(subdir),misc)
+  sysdep_routines += prctl or1k_clone
+endif
+
+# pull in __syscall_error routine
+libpthread-routines += sysdep
+librt-routines += sysdep
+
--- /dev/null
+++ eglibc-2.18/ports/sysdeps/unix/sysv/linux/or1k/ioctl.c
@@ -0,0 +1,38 @@
+/* Copyright (C) 1998, 2002, 2003, 2004 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <stdarg.h>
+#include <sysdep.h>
+
+/* or1k ABI uses stack for varargs, syscall uses registers.
+ * This function moves from varargs to regs. */
+int
+__ioctl (int fd, unsigned long int request, ...)
+{
+  void *arg;
+  va_list ap;
+  int result;
+
+  va_start (ap, request);
+  arg = va_arg (ap, void *);
+
+  result = INLINE_SYSCALL (ioctl, 3, fd, request, arg);
+  va_end (ap);
+
+  return result;
+}
+weak_alias (__ioctl, ioctl)
--- /dev/null
+++ eglibc-2.18/ports/sysdeps/unix/sysv/linux/or1k/semctl.c
@@ -0,0 +1 @@
+#include <sysdeps/unix/sysv/linux/alpha/semctl.c>
--- /dev/null
+++ eglibc-2.18/ports/sysdeps/unix/sysv/linux/or1k/configure.in
@@ -0,0 +1,4 @@
+GLIBC_PROVIDES dnl See aclocal.m4 in the top level source directory.
+# Local configure fragment for sysdeps/unix/sysv/linux/or1k.
+
+arch_minimum_kernel=3.4.0
--- /dev/null
+++ eglibc-2.18/ports/sysdeps/unix/sysv/linux/or1k/kernel-features.h
@@ -0,0 +1,39 @@
+/* Set flags signalling availability of kernel features based on given
+   kernel version number.
+
+   Copyright (C) 2009-2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <linux/version.h>
+
+/* AArch64 support starts with 3.7.0, guaranteeing many kernel
+   features.  */
+
+#define __ASSUME_ACCEPT4                1
+#define __ASSUME_DUP3                   1
+#define __ASSUME_EVENTFD2		1
+#define __ASSUME_IN_NONBLOCK            1
+#define __ASSUME_O_CLOEXEC              1
+#define __ASSUME_PIPE2                  1
+#define __ASSUME_SIGNALFD4		1
+#define __ASSUME_SOCK_CLOEXEC           1
+#define __ASSUME_UTIMES                 1
+
+#include_next <kernel-features.h>
+
+#undef __ASSUME_SET_ROBUST_LIST
--- /dev/null
+++ eglibc-2.18/ports/sysdeps/unix/sysv/linux/or1k/profil-counter.h
@@ -0,0 +1,20 @@
+/* Copyright (C) 2009-2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* We can use the ix86 version.  */
+#include <sysdeps/unix/sysv/linux/i386/profil-counter.h>
--- /dev/null
+++ eglibc-2.18/ports/sysdeps/unix/sysv/linux/or1k/syscall.S
@@ -0,0 +1,32 @@
+
+.globl syscall
+.type syscall,%function
+.align 4
+syscall: 
+  .cfi_sections .debug_frame
+  .cfi_startproc
+
+  l.ori r11, r3, 0
+  l.ori r3, r4, 0
+  l.ori r4, r5, 0
+  l.ori r5, r6, 0
+  l.ori r6, r7, 0
+  l.ori r7, r8, 0
+  l.lwz r8, 0(r1)
+  l.sys 1
+  l.nop
+
+  /* if -4096 < ret < 0 holds, it's an error */
+  l.sfgeui r11, 0xf001
+  l.bf 0f
+  l.nop
+
+  l.jr r9
+  l.nop
+
+0: 
+  l.j __syscall_error
+  l.ori r3,r11,0
+
+  .cfi_endproc
+  .size syscall,.-syscall
--- /dev/null
+++ eglibc-2.18/ports/sysdeps/unix/sysv/linux/or1k/configure
@@ -0,0 +1,3 @@
+# This file is generated from configure.in by Autoconf.  DO NOT EDIT!
+
+arch_minimum_kernel=3.4.0
--- /dev/null
+++ eglibc-2.18/ports/sysdeps/unix/sysv/linux/or1k/Implies
@@ -0,0 +1,2 @@
+unix/sysv/linux/generic/wordsize-32
+unix/sysv/linux/generic
--- /dev/null
+++ eglibc-2.18/ports/sysdeps/unix/sysv/linux/or1k/bits/pthreadtypes.h
@@ -0,0 +1,173 @@
+/* Copyright (C) 2002-2007, 2012 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _BITS_PTHREADTYPES_H
+#define _BITS_PTHREADTYPES_H	1
+
+#include <bits/wordsize.h>
+
+/* TODO: fix these! */
+#define __SIZEOF_PTHREAD_ATTR_T 32
+#define __SIZEOF_PTHREAD_MUTEX_T 32
+#define __SIZEOF_PTHREAD_MUTEXATTR_T 4
+#define __SIZEOF_PTHREAD_COND_T 48
+#define __SIZEOF_PTHREAD_CONDATTR_T 4
+#define __SIZEOF_PTHREAD_RWLOCK_T 44
+#define __SIZEOF_PTHREAD_RWLOCKATTR_T 8
+#define __SIZEOF_PTHREAD_BARRIER_T 20
+#define __SIZEOF_PTHREAD_BARRIERATTR_T 4
+
+
+/* Thread identifiers.  The structure of the attribute type is not
+   exposed on purpose.  */
+typedef unsigned long int pthread_t;
+
+
+union pthread_attr_t
+{
+  char __size[__SIZEOF_PTHREAD_ATTR_T];
+  long int __align;
+};
+#ifndef __have_pthread_attr_t
+typedef union pthread_attr_t pthread_attr_t;
+# define __have_pthread_attr_t	1
+#endif
+
+
+typedef struct __pthread_internal_list
+{
+  struct __pthread_internal_list *__prev;
+  struct __pthread_internal_list *__next;
+} __pthread_list_t;
+
+/* Data structures for mutex handling.  The structure of the attribute
+   type is not exposed on purpose.  */
+typedef union
+{
+  struct __pthread_mutex_s
+  {
+    int __lock;
+    unsigned int __count;
+    int __owner;
+    unsigned int __nusers;
+    /* KIND must stay at this position in the structure to maintain
+       binary compatibility.  */
+    int __kind;
+    int __spins;
+    __pthread_list_t __list;
+# define __PTHREAD_MUTEX_HAVE_PREV	1
+  } __data;
+  char __size[__SIZEOF_PTHREAD_MUTEX_T];
+  long int __align;
+} pthread_mutex_t;
+
+typedef union
+{
+  char __size[__SIZEOF_PTHREAD_MUTEXATTR_T];
+  int __align;
+} pthread_mutexattr_t;
+
+
+/* Data structure for conditional variable handling.  The structure of
+   the attribute type is not exposed on purpose.  */
+typedef union
+{
+  struct
+  {
+    int __lock;
+    unsigned int __futex;
+    __extension__ unsigned long long int __total_seq;
+    __extension__ unsigned long long int __wakeup_seq;
+    __extension__ unsigned long long int __woken_seq;
+    void *__mutex;
+    unsigned int __nwaiters;
+    unsigned int __broadcast_seq;
+  } __data;
+  char __size[__SIZEOF_PTHREAD_COND_T];
+  __extension__ long long int __align;
+} pthread_cond_t;
+
+typedef union
+{
+  char __size[__SIZEOF_PTHREAD_CONDATTR_T];
+  int __align;
+} pthread_condattr_t;
+
+
+/* Keys for thread-specific data */
+typedef unsigned int pthread_key_t;
+
+
+/* Once-only execution */
+typedef int pthread_once_t;
+
+
+#if defined __USE_UNIX98 || defined __USE_XOPEN2K
+/* Data structure for read-write lock variable handling.  The
+   structure of the attribute type is not exposed on purpose.  */
+typedef union
+{
+  struct
+  {
+    int __lock;
+    unsigned int __nr_readers;
+    unsigned int __readers_wakeup;
+    unsigned int __writer_wakeup;
+    unsigned int __nr_readers_queued;
+    unsigned int __nr_writers_queued;
+    int __writer;
+    int __shared;
+    unsigned long int __pad1;
+    unsigned long int __pad2;
+    /* FLAGS must stay at this position in the structure to maintain
+       binary compatibility.  */
+    unsigned int __flags;
+# define __PTHREAD_RWLOCK_INT_FLAGS_SHARED	1
+  } __data;
+  char __size[__SIZEOF_PTHREAD_RWLOCK_T];
+  long int __align;
+} pthread_rwlock_t;
+
+typedef union
+{
+  char __size[__SIZEOF_PTHREAD_RWLOCKATTR_T];
+  long int __align;
+} pthread_rwlockattr_t;
+#endif
+
+
+#ifdef __USE_XOPEN2K
+/* POSIX spinlock data type.  */
+typedef volatile int pthread_spinlock_t;
+
+
+/* POSIX barriers data type.  The structure of the type is
+   deliberately not exposed.  */
+typedef union
+{
+  char __size[__SIZEOF_PTHREAD_BARRIER_T];
+  long int __align;
+} pthread_barrier_t;
+
+typedef union
+{
+  char __size[__SIZEOF_PTHREAD_BARRIERATTR_T];
+  int __align;
+} pthread_barrierattr_t;
+#endif
+
+#endif	/* bits/pthreadtypes.h */
--- /dev/null
+++ eglibc-2.18/ports/sysdeps/unix/sysv/linux/or1k/bits/link.h
@@ -0,0 +1,34 @@
+#ifndef _LINK_H
+# error "Never include <bits/link.h> directly; use <link.h> instead."
+#endif
+
+/* Registers for entry into PLT.  */
+typedef struct La_or1k_regs
+{
+  uint32_t lr_reg[31];
+} La_or1k_regs;
+
+/* Return values for calls from PLT.  */
+typedef struct La_or1k_retval
+{
+  uint32_t lr_r3;
+} La_or1k_retval;
+
+
+__BEGIN_DECLS
+
+extern ElfW(Addr) la_or1k_gnu_pltenter (ElfW(Sym) *__sym, unsigned int __ndx,
+                                        uintptr_t *__refcook,
+                                        uintptr_t *__defcook,
+                                        La_or1k_regs *__regs,
+                                        unsigned int *__flags,
+                                        const char *__symname,
+                                        long int *__framesizep);
+extern unsigned int la_or1k_gnu_pltexit (ElfW(Sym) *__sym, unsigned int __ndx,
+                                         uintptr_t *__refcook,
+                                         uintptr_t *__defcook,
+                                         const La_or1k_regs *__inregs,
+                                         La_or1k_retval *__outregs,
+                                         const char *__symname);
+
+__END_DECLS
--- /dev/null
+++ eglibc-2.18/ports/sysdeps/unix/sysv/linux/or1k/bits/statfs.h
@@ -0,0 +1,83 @@
+/* Copyright (C) 2011 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Chris Metcalf <cmetcalf@tilera.com>, 2011.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _SYS_STATFS_H
+# error "Never include <bits/statfs.h> directly; use <sys/statfs.h> instead."
+#endif
+
+#include <endian.h>
+#include <bits/types.h>
+#include <bits/wordsize.h>
+
+/* 64-bit libc uses the kernel's 'struct statfs', accessed via the
+   statfs() syscall; 32-bit libc uses the kernel's 'struct statfs64'
+   and accesses it via the statfs64() syscall.  All the various
+   APIs offered by libc use the kernel shape for their struct statfs
+   structure; the only difference is that 32-bit programs not
+   using __USE_FILE_OFFSET64 only see the low 32 bits of some
+   of the fields (the __fsblkcnt_t and __fsfilcnt_t fields).  */
+
+/* TODO: or1k gcc doesn't handle alignment as it should.
+ * when that is fixed, remove this file to use default */
+#if defined __USE_FILE_OFFSET64
+# define __field64(type, type64, name) type64 name
+#else
+# define __field64(type, type64, name) \
+  int __##name##_pad __attribute__((__aligned__(4))); type name
+#endif
+
+struct statfs
+  {
+    __SWORD_TYPE f_type;
+    __SWORD_TYPE f_bsize;
+    __field64(__fsblkcnt_t, __fsblkcnt64_t, f_blocks);
+    __field64(__fsblkcnt_t, __fsblkcnt64_t, f_bfree);
+    __field64(__fsblkcnt_t, __fsblkcnt64_t, f_bavail);
+    __field64(__fsfilcnt_t, __fsfilcnt64_t, f_files);
+    __field64(__fsfilcnt_t, __fsfilcnt64_t, f_ffree);
+    __fsid_t f_fsid;
+    __SWORD_TYPE f_namelen;
+    __SWORD_TYPE f_frsize;
+    __SWORD_TYPE f_flags;
+    __SWORD_TYPE f_spare[4];
+  } __attribute__((__aligned__(4)));
+
+#undef __field64
+
+#ifdef __USE_LARGEFILE64
+struct statfs64
+  {
+    __SWORD_TYPE f_type;
+    __SWORD_TYPE f_bsize;
+    __fsblkcnt64_t f_blocks;
+    __fsblkcnt64_t f_bfree;
+    __fsblkcnt64_t f_bavail;
+    __fsfilcnt64_t f_files;
+    __fsfilcnt64_t f_ffree;
+    __fsid_t f_fsid;
+    __SWORD_TYPE f_namelen;
+    __SWORD_TYPE f_frsize;
+    __SWORD_TYPE f_flags;
+    __SWORD_TYPE f_spare[4];
+  } __attribute__((__aligned__(4)));
+#endif
+
+/* Tell code we have these members.  */
+#define _STATFS_F_NAMELEN
+#define _STATFS_F_FRSIZE
+#define _STATFS_F_FLAGS
--- /dev/null
+++ eglibc-2.18/ports/sysdeps/unix/sysv/linux/or1k/bits/fcntl.h
@@ -0,0 +1,49 @@
+/* O_*, F_*, FD_* bit values for Linux.
+   Copyright (C) 2000-2012 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef	_FCNTL_H
+# error "Never use <bits/fcntl.h> directly; include <fcntl.h> instead."
+#endif
+
+struct flock
+  {
+    short int l_type;	/* Type of lock: F_RDLCK, F_WRLCK, or F_UNLCK.	*/
+    short int l_whence;	/* Where `l_start' is relative to (like `lseek').  */
+#ifndef __USE_FILE_OFFSET64
+    __off_t l_start;	/* Offset where the lock begins.  */
+    __off_t l_len;	/* Size of the locked area; zero means until EOF.  */
+#else
+    __off64_t l_start;	/* Offset where the lock begins.  */
+    __off64_t l_len;	/* Size of the locked area; zero means until EOF.  */
+#endif
+    __pid_t l_pid;	/* Process holding the lock.  */
+  };
+
+#ifdef __USE_LARGEFILE64
+struct flock64
+  {
+    short int l_type;	/* Type of lock: F_RDLCK, F_WRLCK, or F_UNLCK.	*/
+    short int l_whence;	/* Where `l_start' is relative to (like `lseek').  */
+    __off64_t l_start;	/* Offset where the lock begins.  */
+    __off64_t l_len;	/* Size of the locked area; zero means until EOF.  */
+    __pid_t l_pid;	/* Process holding the lock.  */
+  };
+#endif
+
+/* Include generic Linux declarations.  */
+#include <bits/fcntl-linux.h>
--- /dev/null
+++ eglibc-2.18/ports/sysdeps/unix/sysv/linux/or1k/bits/mman.h
@@ -0,0 +1,116 @@
+/* Definitions for POSIX memory map interface.  Linux/AArch64 version.
+
+   Copyright (C) 1997-2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _SYS_MMAN_H
+# error "Never use <bits/mman.h> directly; include <sys/mman.h> instead."
+#endif
+
+/* The following definitions basically come from the kernel headers.
+   But the kernel header is not namespace clean.  */
+
+
+/* Protections are chosen from these bits, OR'd together.  The
+   implementation does not necessarily support PROT_EXEC or PROT_WRITE
+   without PROT_READ.  The only guarantees are that no writing will be
+   allowed without PROT_WRITE and no access will be allowed for PROT_NONE. */
+
+#define PROT_READ       0x1             /* Page can be read.  */
+#define PROT_WRITE      0x2             /* Page can be written.  */
+#define PROT_EXEC       0x4             /* Page can be executed.  */
+#define PROT_SEM        0x8             /* Page may be used for atomic ops */
+#define PROT_NONE       0x0             /* Page can not be accessed.  */
+#define PROT_GROWSDOWN  0x01000000      /* Extend change to start of
+                                           growsdown vma (mprotect only).  */
+#define PROT_GROWSUP    0x02000000      /* Extend change to start of
+                                           growsup vma (mprotect only).  */
+
+/* Sharing types (must choose one and only one of these).  */
+#define MAP_SHARED      0x01            /* Share changes.  */
+#define MAP_PRIVATE     0x02            /* Changes are private.  */
+#ifdef __USE_MISC
+# define MAP_TYPE       0x0f            /* Mask for type of mapping.  */
+#endif
+
+/* Other flags.  */
+#define MAP_FIXED       0x10            /* Interpret addr exactly.  */
+#ifdef __USE_MISC
+# define MAP_FILE       0
+# define MAP_ANONYMOUS  0x20            /* Don't use a file.  */
+# define MAP_ANON       MAP_ANONYMOUS
+#endif
+
+#ifdef __USE_MISC
+/* These are Linux-specific.  */
+# define MAP_GROWSDOWN  0x00100         /* Stack-like segment.  */
+# define MAP_DENYWRITE  0x00800         /* ETXTBSY */
+# define MAP_EXECUTABLE 0x01000         /* Mark it as an executable.  */
+# define MAP_LOCKED     0x02000         /* Lock the mapping.  */
+# define MAP_NORESERVE  0x04000         /* Don't check for reservations.  */
+# define MAP_POPULATE   0x08000         /* Populate (prefault) pagetables.  */
+# define MAP_NONBLOCK   0x10000         /* Do not block on IO.  */
+# define MAP_STACK      0x20000         /* Allocation is for a stack.  */
+# define MAP_HUGETLB    0x40000         /* Create huge page mapping.  */
+#endif
+
+/* Flags to `msync'.  */
+#define MS_ASYNC        1               /* Sync memory asynchronously.  */
+#define MS_SYNC         4               /* Synchronous memory sync.  */
+#define MS_INVALIDATE   2               /* Invalidate the caches.  */
+
+/* Flags for `mlockall'.  */
+#define MCL_CURRENT     1               /* Lock all currently mapped pages.  */
+#define MCL_FUTURE      2               /* Lock all additions to address
+                                           space.  */
+
+/* Flags for `mremap'.  */
+#ifdef __USE_GNU
+# define MREMAP_MAYMOVE 1
+# define MREMAP_FIXED   2
+#endif
+
+/* Advice to `madvise'.  */
+#ifdef __USE_BSD
+# define MADV_NORMAL       0     /* No further special treatment.  */
+# define MADV_RANDOM       1     /* Expect random page references.  */
+# define MADV_SEQUENTIAL   2     /* Expect sequential page references.  */
+# define MADV_WILLNEED     3     /* Will need these pages.  */
+# define MADV_DONTNEED     4     /* Don't need these pages.  */
+# define MADV_REMOVE       9     /* Remove these pages and resources.  */
+# define MADV_DONTFORK     10    /* Do not inherit across fork.  */
+# define MADV_DOFORK       11    /* Do inherit across fork.  */
+# define MADV_MERGEABLE    12    /* KSM may merge identical pages.  */
+# define MADV_UNMERGEABLE  13    /* KSM may not merge identical pages.  */
+# define MADV_HUGEPAGE     14    /* Worth backing with hugepages.  */
+# define MADV_NOHUGEPAGE   15    /* Not worth backing with hugepages.  */
+# define MADV_DONTDUMP     16    /* Explicity exclude from the core dump,
+                                    overrides the coredump filter bits.  */
+# define MADV_DODUMP       17    /* Clear the MADV_DONTDUMP flag.  */
+# define MADV_HWPOISON     100   /* Poison a page for testing.  */
+# define MADV_SOFT_OFFLINE 101   /* Soft offline page for testing */
+#endif
+
+/* The POSIX people had to invent similar names for the same things.  */
+#ifdef __USE_XOPEN2K
+# define POSIX_MADV_NORMAL      0 /* No further special treatment.  */
+# define POSIX_MADV_RANDOM      1 /* Expect random page references.  */
+# define POSIX_MADV_SEQUENTIAL  2 /* Expect sequential page references.  */
+# define POSIX_MADV_WILLNEED    3 /* Will need these pages.  */
+# define POSIX_MADV_DONTNEED    4 /* Don't need these pages.  */
+#endif
--- /dev/null
+++ eglibc-2.18/ports/sysdeps/unix/sysv/linux/or1k/bits/siginfo.h
@@ -0,0 +1,341 @@
+/* siginfo_t, sigevent and constants.  Linux x86-64 version.
+   Copyright (C) 2012 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#if !defined _SIGNAL_H && !defined __need_siginfo_t \
+    && !defined __need_sigevent_t
+# error "Never include this file directly.  Use <signal.h> instead"
+#endif
+
+#include <bits/wordsize.h>
+
+#if (!defined __have_sigval_t \
+     && (defined _SIGNAL_H || defined __need_siginfo_t \
+	 || defined __need_sigevent_t))
+# define __have_sigval_t	1
+
+/* Type for data associated with a signal.  */
+typedef union sigval
+  {
+    int sival_int;
+    void *sival_ptr;
+  } sigval_t;
+#endif
+
+#if (!defined __have_siginfo_t \
+     && (defined _SIGNAL_H || defined __need_siginfo_t))
+# define __have_siginfo_t	1
+
+# define __SI_MAX_SIZE     128
+# if __WORDSIZE == 64
+#  define __SI_PAD_SIZE     ((__SI_MAX_SIZE / sizeof (int)) - 4)
+# else
+#  define __SI_PAD_SIZE     ((__SI_MAX_SIZE / sizeof (int)) - 3)
+# endif
+
+# if defined __x86_64__ && __WORDSIZE == 32
+/* si_utime and si_stime must be 4 byte aligned for x32 to match the
+   kernel.  We align siginfo_t to 8 bytes so that si_utime and si_stime
+   are actually aligned to 8 bytes since their offsets are multiple of
+   8 bytes.  */
+typedef __clock_t __attribute__ ((__aligned__ (4))) __sigchld_clock_t;
+#  define __SI_ALIGNMENT __attribute__ ((__aligned__ (8)))
+# else
+typedef __clock_t __sigchld_clock_t;
+#  define __SI_ALIGNMENT
+# endif
+
+typedef struct
+  {
+    int si_signo;		/* Signal number.  */
+    int si_errno;		/* If non-zero, an errno value associated with
+				   this signal, as defined in <errno.h>.  */
+    int si_code;		/* Signal code.  */
+
+    union
+      {
+	int _pad[__SI_PAD_SIZE];
+
+	 /* kill().  */
+	struct
+	  {
+	    __pid_t si_pid;	/* Sending process ID.  */
+	    __uid_t si_uid;	/* Real user ID of sending process.  */
+	  } _kill;
+
+	/* POSIX.1b timers.  */
+	struct
+	  {
+	    int si_tid;		/* Timer ID.  */
+	    int si_overrun;	/* Overrun count.  */
+	    sigval_t si_sigval;	/* Signal value.  */
+	  } _timer;
+
+	/* POSIX.1b signals.  */
+	struct
+	  {
+	    __pid_t si_pid;	/* Sending process ID.  */
+	    __uid_t si_uid;	/* Real user ID of sending process.  */
+	    sigval_t si_sigval;	/* Signal value.  */
+	  } _rt;
+
+	/* SIGCHLD.  */
+	struct
+	  {
+	    __pid_t si_pid;	/* Which child.  */
+	    __uid_t si_uid;	/* Real user ID of sending process.  */
+	    int si_status;	/* Exit value or signal.  */
+	    __sigchld_clock_t si_utime;
+	    __sigchld_clock_t si_stime;
+	  } _sigchld;
+
+	/* SIGILL, SIGFPE, SIGSEGV, SIGBUS.  */
+	struct
+	  {
+	    void *si_addr;	/* Faulting insn/memory ref.  */
+	  } _sigfault;
+
+	/* SIGPOLL.  */
+	struct
+	  {
+	    long int si_band;	/* Band event for SIGPOLL.  */
+	    int si_fd;
+	  } _sigpoll;
+
+	/* SIGSYS.  */
+	struct
+	  {
+	    void *_call_addr;	/* Calling user insn.  */
+	    int _syscall;	/* Triggering system call number.  */
+	    unsigned int _arch; /* AUDIT_ARCH_* of syscall.  */
+	  } _sigsys;
+      } _sifields;
+  } siginfo_t __SI_ALIGNMENT;
+
+
+/* X/Open requires some more fields with fixed names.  */
+# define si_pid		_sifields._kill.si_pid
+# define si_uid		_sifields._kill.si_uid
+# define si_timerid	_sifields._timer.si_tid
+# define si_overrun	_sifields._timer.si_overrun
+# define si_status	_sifields._sigchld.si_status
+# define si_utime	_sifields._sigchld.si_utime
+# define si_stime	_sifields._sigchld.si_stime
+# define si_value	_sifields._rt.si_sigval
+# define si_int		_sifields._rt.si_sigval.sival_int
+# define si_ptr		_sifields._rt.si_sigval.sival_ptr
+# define si_addr	_sifields._sigfault.si_addr
+# define si_band	_sifields._sigpoll.si_band
+# define si_fd		_sifields._sigpoll.si_fd
+# define si_call_addr 	_sifields._sigsys._call_addr
+# define si_syscall	_sifields._sigsys._syscall
+# define si_arch	_sifields._sigsys._arch
+
+
+/* Values for `si_code'.  Positive values are reserved for kernel-generated
+   signals.  */
+enum
+{
+  SI_ASYNCNL = -60,		/* Sent by asynch name lookup completion.  */
+# define SI_ASYNCNL	SI_ASYNCNL
+  SI_TKILL = -6,		/* Sent by tkill.  */
+# define SI_TKILL	SI_TKILL
+  SI_SIGIO,			/* Sent by queued SIGIO. */
+# define SI_SIGIO	SI_SIGIO
+  SI_ASYNCIO,			/* Sent by AIO completion.  */
+# define SI_ASYNCIO	SI_ASYNCIO
+  SI_MESGQ,			/* Sent by real time mesq state change.  */
+# define SI_MESGQ	SI_MESGQ
+  SI_TIMER,			/* Sent by timer expiration.  */
+# define SI_TIMER	SI_TIMER
+  SI_QUEUE,			/* Sent by sigqueue.  */
+# define SI_QUEUE	SI_QUEUE
+  SI_USER,			/* Sent by kill, sigsend.  */
+# define SI_USER	SI_USER
+  SI_KERNEL = 0x80		/* Send by kernel.  */
+#define SI_KERNEL	SI_KERNEL
+};
+
+
+/* `si_code' values for SIGILL signal.  */
+enum
+{
+  ILL_ILLOPC = 1,		/* Illegal opcode.  */
+# define ILL_ILLOPC	ILL_ILLOPC
+  ILL_ILLOPN,			/* Illegal operand.  */
+# define ILL_ILLOPN	ILL_ILLOPN
+  ILL_ILLADR,			/* Illegal addressing mode.  */
+# define ILL_ILLADR	ILL_ILLADR
+  ILL_ILLTRP,			/* Illegal trap. */
+# define ILL_ILLTRP	ILL_ILLTRP
+  ILL_PRVOPC,			/* Privileged opcode.  */
+# define ILL_PRVOPC	ILL_PRVOPC
+  ILL_PRVREG,			/* Privileged register.  */
+# define ILL_PRVREG	ILL_PRVREG
+  ILL_COPROC,			/* Coprocessor error.  */
+# define ILL_COPROC	ILL_COPROC
+  ILL_BADSTK			/* Internal stack error.  */
+# define ILL_BADSTK	ILL_BADSTK
+};
+
+/* `si_code' values for SIGFPE signal.  */
+enum
+{
+  FPE_INTDIV = 1,		/* Integer divide by zero.  */
+# define FPE_INTDIV	FPE_INTDIV
+  FPE_INTOVF,			/* Integer overflow.  */
+# define FPE_INTOVF	FPE_INTOVF
+  FPE_FLTDIV,			/* Floating point divide by zero.  */
+# define FPE_FLTDIV	FPE_FLTDIV
+  FPE_FLTOVF,			/* Floating point overflow.  */
+# define FPE_FLTOVF	FPE_FLTOVF
+  FPE_FLTUND,			/* Floating point underflow.  */
+# define FPE_FLTUND	FPE_FLTUND
+  FPE_FLTRES,			/* Floating point inexact result.  */
+# define FPE_FLTRES	FPE_FLTRES
+  FPE_FLTINV,			/* Floating point invalid operation.  */
+# define FPE_FLTINV	FPE_FLTINV
+  FPE_FLTSUB			/* Subscript out of range.  */
+# define FPE_FLTSUB	FPE_FLTSUB
+};
+
+/* `si_code' values for SIGSEGV signal.  */
+enum
+{
+  SEGV_MAPERR = 1,		/* Address not mapped to object.  */
+# define SEGV_MAPERR	SEGV_MAPERR
+  SEGV_ACCERR			/* Invalid permissions for mapped object.  */
+# define SEGV_ACCERR	SEGV_ACCERR
+};
+
+/* `si_code' values for SIGBUS signal.  */
+enum
+{
+  BUS_ADRALN = 1,		/* Invalid address alignment.  */
+# define BUS_ADRALN	BUS_ADRALN
+  BUS_ADRERR,			/* Non-existant physical address.  */
+# define BUS_ADRERR	BUS_ADRERR
+  BUS_OBJERR			/* Object specific hardware error.  */
+# define BUS_OBJERR	BUS_OBJERR
+};
+
+/* `si_code' values for SIGTRAP signal.  */
+enum
+{
+  TRAP_BRKPT = 1,		/* Process breakpoint.  */
+# define TRAP_BRKPT	TRAP_BRKPT
+  TRAP_TRACE			/* Process trace trap.  */
+# define TRAP_TRACE	TRAP_TRACE
+};
+
+/* `si_code' values for SIGCHLD signal.  */
+enum
+{
+  CLD_EXITED = 1,		/* Child has exited.  */
+# define CLD_EXITED	CLD_EXITED
+  CLD_KILLED,			/* Child was killed.  */
+# define CLD_KILLED	CLD_KILLED
+  CLD_DUMPED,			/* Child terminated abnormally.  */
+# define CLD_DUMPED	CLD_DUMPED
+  CLD_TRAPPED,			/* Traced child has trapped.  */
+# define CLD_TRAPPED	CLD_TRAPPED
+  CLD_STOPPED,			/* Child has stopped.  */
+# define CLD_STOPPED	CLD_STOPPED
+  CLD_CONTINUED			/* Stopped child has continued.  */
+# define CLD_CONTINUED	CLD_CONTINUED
+};
+
+/* `si_code' values for SIGPOLL signal.  */
+enum
+{
+  POLL_IN = 1,			/* Data input available.  */
+# define POLL_IN	POLL_IN
+  POLL_OUT,			/* Output buffers available.  */
+# define POLL_OUT	POLL_OUT
+  POLL_MSG,			/* Input message available.   */
+# define POLL_MSG	POLL_MSG
+  POLL_ERR,			/* I/O error.  */
+# define POLL_ERR	POLL_ERR
+  POLL_PRI,			/* High priority input available.  */
+# define POLL_PRI	POLL_PRI
+  POLL_HUP			/* Device disconnected.  */
+# define POLL_HUP	POLL_HUP
+};
+
+# undef __need_siginfo_t
+#endif	/* !have siginfo_t && (have _SIGNAL_H || need siginfo_t).  */
+
+
+#if (defined _SIGNAL_H || defined __need_sigevent_t) \
+    && !defined __have_sigevent_t
+# define __have_sigevent_t	1
+
+/* Structure to transport application-defined values with signals.  */
+# define __SIGEV_MAX_SIZE	64
+# if __WORDSIZE == 64
+#  define __SIGEV_PAD_SIZE	((__SIGEV_MAX_SIZE / sizeof (int)) - 4)
+# else
+#  define __SIGEV_PAD_SIZE	((__SIGEV_MAX_SIZE / sizeof (int)) - 3)
+# endif
+
+/* Forward declaration.  */
+# ifndef __have_pthread_attr_t
+typedef union pthread_attr_t pthread_attr_t;
+#  define __have_pthread_attr_t	1
+# endif
+
+typedef struct sigevent
+  {
+    sigval_t sigev_value;
+    int sigev_signo;
+    int sigev_notify;
+
+    union
+      {
+	int _pad[__SIGEV_PAD_SIZE];
+
+	/* When SIGEV_SIGNAL and SIGEV_THREAD_ID set, LWP ID of the
+	   thread to receive the signal.  */
+	__pid_t _tid;
+
+	struct
+	  {
+	    void (*_function) (sigval_t);	/* Function to start.  */
+	    pthread_attr_t *_attribute;		/* Thread attributes.  */
+	  } _sigev_thread;
+      } _sigev_un;
+  } sigevent_t;
+
+/* POSIX names to access some of the members.  */
+# define sigev_notify_function   _sigev_un._sigev_thread._function
+# define sigev_notify_attributes _sigev_un._sigev_thread._attribute
+
+/* `sigev_notify' values.  */
+enum
+{
+  SIGEV_SIGNAL = 0,		/* Notify via signal.  */
+# define SIGEV_SIGNAL	SIGEV_SIGNAL
+  SIGEV_NONE,			/* Other notification: meaningless.  */
+# define SIGEV_NONE	SIGEV_NONE
+  SIGEV_THREAD,			/* Deliver via thread creation.  */
+# define SIGEV_THREAD	SIGEV_THREAD
+
+  SIGEV_THREAD_ID = 4		/* Send signal to specific thread.  */
+#define SIGEV_THREAD_ID	SIGEV_THREAD_ID
+};
+
+#endif	/* have _SIGNAL_H.  */
--- /dev/null
+++ eglibc-2.18/ports/sysdeps/unix/sysv/linux/or1k/sys/user.h
@@ -0,0 +1 @@
+/* This file is not needed, but in practice gdb might try to include it.  */
--- /dev/null
+++ eglibc-2.18/ports/sysdeps/unix/sysv/linux/or1k/sys/procfs.h
@@ -0,0 +1,118 @@
+/* Copyright (C) 1996, 1997, 1999, 2001 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _SYS_PROCFS_H
+#define _SYS_PROCFS_H	1
+
+/* This is somewhat modelled after the file of the same name on SVR4
+   systems.  It provides a definition of the core file format for ELF
+   used on Linux.  It doesn't have anything to do with the /proc file
+   system, even though Linux has one.
+
+   Anyway, the whole purpose of this file is for GDB and GDB only.
+   Don't read too much into it.  Don't use it for anything other than
+   GDB unless you know what you are doing.  */
+
+#include <features.h>
+#include <sys/time.h>
+#include <sys/types.h>
+#include <sys/user.h>
+#include <asm/elf.h>
+
+__BEGIN_DECLS
+
+/* Type for a general-purpose register.  */
+typedef unsigned long elf_greg_t;
+
+/* And the whole bunch of them.  We could have used `struct
+   user_regs' directly in the typedef, but tradition says that
+   the register set is an array, which does have some peculiar
+   semantics, so leave it that way.  */
+
+/* Signal info.  */
+struct elf_siginfo
+  {
+    int si_signo;			/* Signal number.  */
+    int si_code;			/* Extra code.  */
+    int si_errno;			/* Errno.  */
+  };
+
+/* Definitions to generate Intel SVR4-like core files.  These mostly
+   have the same names as the SVR4 types with "elf_" tacked on the
+   front to prevent clashes with Linux definitions, and the typedef
+   forms have been avoided.  This is mostly like the SVR4 structure,
+   but more Linuxy, with things that Linux does not support and which
+   GDB doesn't really use excluded.  */
+
+struct elf_prstatus
+  {
+    struct elf_siginfo pr_info;		/* Info associated with signal.  */
+    short int pr_cursig;		/* Current signal.  */
+    unsigned long int pr_sigpend;	/* Set of pending signals.  */
+    unsigned long int pr_sighold;	/* Set of held signals.  */
+    __pid_t pr_pid;
+    __pid_t pr_ppid;
+    __pid_t pr_pgrp;
+    __pid_t pr_sid;
+    struct timeval pr_utime;		/* User time.  */
+    struct timeval pr_stime;		/* System time.  */
+    struct timeval pr_cutime;		/* Cumulative user time.  */
+    struct timeval pr_cstime;		/* Cumulative system time.  */
+    elf_gregset_t pr_reg;		/* GP registers.  */
+    int pr_fpvalid;			/* True if math copro being used.  */
+  };
+
+
+#define ELF_PRARGSZ     (80)    /* Number of chars for args.  */
+
+struct elf_prpsinfo
+  {
+    char pr_state;			/* Numeric process state.  */
+    char pr_sname;			/* Char for pr_state.  */
+    char pr_zomb;			/* Zombie.  */
+    char pr_nice;			/* Nice val.  */
+    unsigned long int pr_flag;		/* Flags.  */
+    unsigned short int pr_uid;
+    unsigned short int pr_gid;
+    int pr_pid, pr_ppid, pr_pgrp, pr_sid;
+    /* Lots missing */
+    char pr_fname[16];			/* Filename of executable.  */
+    char pr_psargs[ELF_PRARGSZ];	/* Initial part of arg list.  */
+  };
+
+/* The rest of this file provides the types for emulation of the
+   Solaris <proc_service.h> interfaces that should be implemented by
+   users of libthread_db.  */
+
+/* Addresses.  */
+typedef void *psaddr_t;
+
+/* Register sets.  Linux has different names.  */
+typedef elf_gregset_t prgregset_t;
+typedef elf_fpregset_t prfpregset_t;
+
+/* We don't have any differences between processes and threads,
+   therefore have only one PID type.  */
+typedef __pid_t lwpid_t;
+
+/* Process status and info.  In the end we do provide typedefs for them.  */
+typedef struct elf_prstatus prstatus_t;
+typedef struct elf_prpsinfo prpsinfo_t;
+
+__END_DECLS
+
+#endif	/* sys/procfs.h */
--- /dev/null
+++ eglibc-2.18/ports/sysdeps/unix/sysv/linux/or1k/nptl/ld.abilist
@@ -0,0 +1,18 @@
+GLIBC_2.0
+ GLIBC_2.0 A
+ __libc_memalign F
+ _r_debug D 0x14
+ calloc F
+ free F
+ malloc F
+ realloc F
+GLIBC_2.1
+ GLIBC_2.1 A
+ __libc_stack_end D 0x4
+ _dl_mcount F
+GLIBC_2.3
+ GLIBC_2.3 A
+ __tls_get_addr F
+GLIBC_2.4
+ GLIBC_2.4 A
+ __stack_chk_guard D 0x4
--- /dev/null
+++ eglibc-2.18/ports/sysdeps/unix/sysv/linux/or1k/nptl/pt-vfork.c
@@ -0,0 +1,30 @@
+/* Copyright (C) 1992, 1995, 1997, 2000, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <errno.h>
+#include <unistd.h>
+
+/* If we don't have vfork, fork is close enough.  */
+
+__pid_t
+__vfork (void)
+{
+  return __fork ();
+}
+libc_hidden_def (__vfork)
+
+weak_alias (__vfork, vfork)
--- /dev/null
+++ eglibc-2.18/ports/sysdeps/unix/sysv/linux/or1k/nptl/libthread_db.abilist
@@ -0,0 +1,48 @@
+GLIBC_2.1.3
+ GLIBC_2.1.3 A
+ td_init F
+ td_log F
+ td_ta_clear_event F
+ td_ta_delete F
+ td_ta_enable_stats F
+ td_ta_event_addr F
+ td_ta_event_getmsg F
+ td_ta_get_nthreads F
+ td_ta_get_ph F
+ td_ta_get_stats F
+ td_ta_map_id2thr F
+ td_ta_map_lwp2thr F
+ td_ta_new F
+ td_ta_reset_stats F
+ td_ta_set_event F
+ td_ta_setconcurrency F
+ td_ta_thr_iter F
+ td_ta_tsd_iter F
+ td_thr_clear_event F
+ td_thr_dbresume F
+ td_thr_dbsuspend F
+ td_thr_event_enable F
+ td_thr_event_getmsg F
+ td_thr_get_info F
+ td_thr_getfpregs F
+ td_thr_getgregs F
+ td_thr_getxregs F
+ td_thr_getxregsize F
+ td_thr_set_event F
+ td_thr_setfpregs F
+ td_thr_setgregs F
+ td_thr_setprio F
+ td_thr_setsigpending F
+ td_thr_setxregs F
+ td_thr_sigsetmask F
+ td_thr_tsd F
+ td_thr_validate F
+GLIBC_2.2.3
+ GLIBC_2.2.3 A
+ td_symbol_list F
+GLIBC_2.3
+ GLIBC_2.3 A
+ td_thr_tls_get_addr F
+GLIBC_2.3.3
+ GLIBC_2.3.3 A
+ td_thr_tlsbase F
--- /dev/null
+++ eglibc-2.18/ports/sysdeps/unix/sysv/linux/or1k/nptl/createthread.c
@@ -0,0 +1,23 @@
+/* Copyright (C) 2003, 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Jakub Jelinek <jakub@redhat.com>.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.	 See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* Value passed to 'clone' for initialization of the thread register.  */
+#define TLS_VALUE ((char *) pd + TLS_PRE_TCB_SIZE + TLS_INIT_TCB_SIZE)
+
+/* Get the real implementation.	 */
+#include <nptl/sysdeps/pthread/createthread.c>
--- /dev/null
+++ eglibc-2.18/ports/sysdeps/unix/sysv/linux/or1k/nptl/c++-types.data
@@ -0,0 +1,67 @@
+blkcnt64_t:x
+blkcnt_t:l
+blksize_t:l
+caddr_t:Pc
+clockid_t:i
+clock_t:l
+daddr_t:i
+dev_t:y
+fd_mask:l
+fsblkcnt64_t:y
+fsblkcnt_t:m
+fsfilcnt64_t:y
+fsfilcnt_t:m
+fsid_t:8__fsid_t
+gid_t:j
+id_t:j
+ino64_t:y
+ino_t:m
+int16_t:s
+int32_t:i
+int64_t:x
+int8_t:a
+intptr_t:i
+key_t:i
+loff_t:x
+mode_t:j
+nlink_t:j
+off64_t:x
+off_t:l
+pid_t:i
+pthread_attr_t:14pthread_attr_t
+pthread_barrier_t:17pthread_barrier_t
+pthread_barrierattr_t:21pthread_barrierattr_t
+pthread_cond_t:14pthread_cond_t
+pthread_condattr_t:18pthread_condattr_t
+pthread_key_t:j
+pthread_mutex_t:15pthread_mutex_t
+pthread_mutexattr_t:19pthread_mutexattr_t
+pthread_once_t:i
+pthread_rwlock_t:16pthread_rwlock_t
+pthread_rwlockattr_t:20pthread_rwlockattr_t
+pthread_spinlock_t:i
+pthread_t:m
+quad_t:x
+register_t:i
+rlim64_t:y
+rlim_t:m
+sigset_t:10__sigset_t
+size_t:j
+socklen_t:j
+ssize_t:i
+suseconds_t:l
+time_t:l
+u_char:h
+uid_t:j
+uint:j
+u_int:j
+u_int16_t:t
+u_int32_t:j
+u_int64_t:y
+u_int8_t:h
+ulong:m
+u_long:m
+u_quad_t:y
+useconds_t:j
+ushort:t
+u_short:t
--- /dev/null
+++ eglibc-2.18/ports/sysdeps/unix/sysv/linux/or1k/nptl/libresolv.abilist
@@ -0,0 +1,104 @@
+GLIBC_2.0
+ GLIBC_2.0 A
+ __b64_ntop F
+ __b64_pton F
+ __dn_comp F
+ __dn_count_labels F
+ __dn_skipname F
+ __fp_nquery F
+ __fp_query F
+ __fp_resstat F
+ __hostalias F
+ __loc_aton F
+ __loc_ntoa F
+ __p_cdname F
+ __p_cdnname F
+ __p_class F
+ __p_class_syms D 0x54
+ __p_fqname F
+ __p_fqnname F
+ __p_option F
+ __p_query F
+ __p_secstodate F
+ __p_time F
+ __p_type F
+ __p_type_syms D 0x228
+ __putlong F
+ __putshort F
+ __res_close F
+ __res_dnok F
+ __res_hnok F
+ __res_isourserver F
+ __res_mailok F
+ __res_nameinquery F
+ __res_ownok F
+ __res_queriesmatch F
+ __res_send F
+ __sym_ntop F
+ __sym_ntos F
+ __sym_ston F
+ _gethtbyaddr F
+ _gethtbyname F
+ _gethtbyname2 F
+ _gethtent F
+ _getlong F
+ _getshort F
+ _res_opcodes D 0x40
+ _sethtent F
+ dn_expand F
+ inet_net_ntop F
+ inet_net_pton F
+ inet_neta F
+ res_gethostbyaddr F
+ res_gethostbyname F
+ res_gethostbyname2 F
+ res_mkquery F
+ res_query F
+ res_querydomain F
+ res_search F
+ res_send_setqhook F
+ res_send_setrhook F
+GLIBC_2.2
+ GLIBC_2.2 A
+ __dn_expand F
+ __res_hostalias F
+ __res_mkquery F
+ __res_nmkquery F
+ __res_nquery F
+ __res_nquerydomain F
+ __res_nsearch F
+ __res_nsend F
+ __res_query F
+ __res_querydomain F
+ __res_search F
+GLIBC_2.3.2
+ GLIBC_2.3.2 A
+ __p_rcode F
+GLIBC_2.9
+ GLIBC_2.9 A
+ ns_datetosecs F
+ ns_format_ttl F
+ ns_get16 F
+ ns_get32 F
+ ns_initparse F
+ ns_makecanon F
+ ns_msg_getflag F
+ ns_name_compress F
+ ns_name_ntol F
+ ns_name_ntop F
+ ns_name_pack F
+ ns_name_pton F
+ ns_name_rollback F
+ ns_name_skip F
+ ns_name_uncompress F
+ ns_name_unpack F
+ ns_parse_ttl F
+ ns_parserr F
+ ns_put16 F
+ ns_put32 F
+ ns_samedomain F
+ ns_samename F
+ ns_skiprr F
+ ns_sprintrr F
+ ns_sprintrrf F
+ ns_subdomain F
--- /dev/null
+++ eglibc-2.18/ports/sysdeps/unix/sysv/linux/or1k/nptl/or1k_clone.S
@@ -0,0 +1,92 @@
+#include <sysdep.h>
+#include <linux/sched.h>
+#include <tls.h>
+
+.text
+ENTRY(__or1k_clone)
+
+	/* To handle GCC varargs we need to use our __clone wrapper to pop
+	   everything from the stack for us.
+	   Now everything is placed in the registers which saves us a lot 
+	   of trouble.
+
+	   The userland implementation is:
+		  int clone (int (*fn)(void *), void *child_stack,
+			    int flags, void *arg, pid_t *ptid,
+			    struct user_desc *tls, pid_t *ctid);
+
+	     The kernel entry is:
+		  int clone (long flags, void *child_stack, int *parent_tid,
+			  int *child_tid, struct void *tls)
+	     NB: tls isn't really an argument, it is read from r7 directly.
+	*/
+
+	/* Put 'fn', 'arg' and 'flags' on child stack */
+	l.sw  -4(r4), r3
+	l.sw  -8(r4), r6
+	l.sw  -12(r4), r5
+
+	/* Set all arguments */
+	l.ori r3, r5, 0
+	/* child_stack is already in r4 */
+	l.ori r5, r7, 0
+	l.lwz r6, 0(r1)
+	l.ori r7, r8, 0
+
+	DO_CALL (clone)
+
+	l.sfgeui r11, 0xf001
+	l.bf .Lerror
+	l.nop
+
+	/* If we are not the child, return the pid */
+	l.sfeqi r11, 0
+	l.bf .Lchild
+	l.nop
+
+	l.jr r9
+	l.nop
+
+.Lchild:
+	/* Load flags */
+	l.lwz r3, -12(r1)
+
+	/* Update PID, but only if we do not share the same PID 
+	   as our parent */
+	l.srli  r4, r3, 16
+	l.andi r4, r4, hi(CLONE_THREAD)
+	l.sfnei r4, 0
+	l.bf .Loldpid
+
+	/* If we share the same memory space, reset the PID/TID values.
+	   Apparently getpid caches, so we want to make sure it's flushed */
+	l.ori r11, r0, -1
+	l.andi r4, r3, CLONE_VM
+	l.sfnei r4, 0
+	l.bf .Lsetpid
+	l.nop
+
+	/* Else we update them */
+	DO_CALL (getpid)
+
+.Lsetpid:
+	l.addi r3, r10, TP_TO_PTHREAD_OFFSET
+	l.sw PTHREAD_PID_OFFSET(r3), r11
+	l.sw PTHREAD_TID_OFFSET(r3), r11
+	
+
+.Loldpid:
+	/* Load function from stack */
+	l.lwz r9, -4(r1)
+	l.jr r9
+	l.lwz r3, -8(r1)
+
+	/* Exit the child thread */
+	l.jal HIDDEN_JUMPTARGET(_exit)
+	l.ori r3, r11, 0
+
+.Lerror:
+	l.j SYSCALL_ERROR_NAME
+	l.ori r3,r11,0
+
+PSEUDO_END (__or1k_clone)
--- /dev/null
+++ eglibc-2.18/ports/sysdeps/unix/sysv/linux/or1k/nptl/libBrokenLocale.abilist
@@ -0,0 +1,3 @@
+GLIBC_2.0
+ GLIBC_2.0 A
+ __ctype_get_mb_cur_max F
--- /dev/null
+++ eglibc-2.18/ports/sysdeps/unix/sysv/linux/or1k/nptl/libm.abilist
@@ -0,0 +1,383 @@
+GLIBC_2.0
+ GLIBC_2.0 A
+ _LIB_VERSION D 0x4
+ acos F
+ acosf F
+ acosh F
+ acoshf F
+ acoshl F
+ acosl F
+ asin F
+ asinf F
+ asinh F
+ asinhf F
+ asinhl F
+ asinl F
+ atan F
+ atan2 F
+ atan2f F
+ atan2l F
+ atanf F
+ atanh F
+ atanhf F
+ atanhl F
+ atanl F
+ cbrt F
+ cbrtf F
+ cbrtl F
+ ceil F
+ ceilf F
+ ceill F
+ copysign F
+ copysignf F
+ copysignl F
+ cos F
+ cosf F
+ cosh F
+ coshf F
+ coshl F
+ cosl F
+ drem F
+ dremf F
+ dreml F
+ erf F
+ erfc F
+ erfcf F
+ erfcl F
+ erff F
+ erfl F
+ exp F
+ expf F
+ expl F
+ expm1 F
+ expm1f F
+ expm1l F
+ fabs F
+ fabsf F
+ fabsl F
+ finite F
+ finitef F
+ finitel F
+ floor F
+ floorf F
+ floorl F
+ fmod F
+ fmodf F
+ fmodl F
+ frexp F
+ frexpf F
+ frexpl F
+ gamma F
+ gammaf F
+ gammal F
+ hypot F
+ hypotf F
+ hypotl F
+ ilogb F
+ ilogbf F
+ ilogbl F
+ j0 F
+ j0f F
+ j0l F
+ j1 F
+ j1f F
+ j1l F
+ jn F
+ jnf F
+ jnl F
+ ldexp F
+ ldexpf F
+ ldexpl F
+ lgamma F
+ lgamma_r F
+ lgammaf F
+ lgammaf_r F
+ lgammal F
+ lgammal_r F
+ log F
+ log10 F
+ log10f F
+ log10l F
+ log1p F
+ log1pf F
+ log1pl F
+ logb F
+ logbf F
+ logbl F
+ logf F
+ logl F
+ matherr F
+ modf F
+ modff F
+ modfl F
+ nextafter F
+ nextafterf F
+ nextafterl F
+ pow F
+ powf F
+ powl F
+ remainder F
+ remainderf F
+ remainderl F
+ rint F
+ rintf F
+ rintl F
+ scalb F
+ scalbf F
+ scalbl F
+ scalbn F
+ scalbnf F
+ scalbnl F
+ signgam D 0x4
+ significand F
+ significandf F
+ significandl F
+ sin F
+ sinf F
+ sinh F
+ sinhf F
+ sinhl F
+ sinl F
+ sqrt F
+ sqrtf F
+ sqrtl F
+ tan F
+ tanf F
+ tanh F
+ tanhf F
+ tanhl F
+ tanl F
+ y0 F
+ y0f F
+ y0l F
+ y1 F
+ y1f F
+ y1l F
+ yn F
+ ynf F
+ ynl F
+GLIBC_2.1
+ GLIBC_2.1 A
+ __clog10 F
+ __clog10f F
+ __clog10l F
+ __finite F
+ __finitef F
+ __finitel F
+ __fpclassify F
+ __fpclassifyf F
+ __signbit F
+ __signbitf F
+ cabs F
+ cabsf F
+ cabsl F
+ cacos F
+ cacosf F
+ cacosh F
+ cacoshf F
+ cacoshl F
+ cacosl F
+ carg F
+ cargf F
+ cargl F
+ casin F
+ casinf F
+ casinh F
+ casinhf F
+ casinhl F
+ casinl F
+ catan F
+ catanf F
+ catanh F
+ catanhf F
+ catanhl F
+ catanl F
+ ccos F
+ ccosf F
+ ccosh F
+ ccoshf F
+ ccoshl F
+ ccosl F
+ cexp F
+ cexpf F
+ cexpl F
+ cimag F
+ cimagf F
+ cimagl F
+ clog F
+ clog10 F
+ clog10f F
+ clog10l F
+ clogf F
+ clogl F
+ conj F
+ conjf F
+ conjl F
+ cpow F
+ cpowf F
+ cpowl F
+ cproj F
+ cprojf F
+ cprojl F
+ creal F
+ crealf F
+ creall F
+ csin F
+ csinf F
+ csinh F
+ csinhf F
+ csinhl F
+ csinl F
+ csqrt F
+ csqrtf F
+ csqrtl F
+ ctan F
+ ctanf F
+ ctanh F
+ ctanhf F
+ ctanhl F
+ ctanl F
+ exp10 F
+ exp10f F
+ exp10l F
+ exp2 F
+ exp2f F
+ fdim F
+ fdimf F
+ fdiml F
+ feclearexcept F
+ fegetenv F
+ fegetexceptflag F
+ fegetround F
+ feholdexcept F
+ feraiseexcept F
+ fesetenv F
+ fesetexceptflag F
+ fesetround F
+ fetestexcept F
+ feupdateenv F
+ fma F
+ fmaf F
+ fmal F
+ fmax F
+ fmaxf F
+ fmaxl F
+ fmin F
+ fminf F
+ fminl F
+ llrint F
+ llrintf F
+ llrintl F
+ llround F
+ llroundf F
+ llroundl F
+ log2 F
+ log2f F
+ log2l F
+ lrint F
+ lrintf F
+ lrintl F
+ lround F
+ lroundf F
+ lroundl F
+ nan F
+ nanf F
+ nanl F
+ nearbyint F
+ nearbyintf F
+ nearbyintl F
+ nexttoward F
+ nexttowardf F
+ nexttowardl F
+ pow10 F
+ pow10f F
+ pow10l F
+ remquo F
+ remquof F
+ remquol F
+ round F
+ roundf F
+ roundl F
+ scalbln F
+ scalblnf F
+ scalblnl F
+ sincos F
+ sincosf F
+ sincosl F
+ tgamma F
+ tgammaf F
+ tgammal F
+ trunc F
+ truncf F
+ truncl F
+GLIBC_2.15
+ GLIBC_2.15 A
+ __acos_finite F
+ __acosf_finite F
+ __acosh_finite F
+ __acoshf_finite F
+ __asin_finite F
+ __asinf_finite F
+ __atan2_finite F
+ __atan2f_finite F
+ __atanh_finite F
+ __atanhf_finite F
+ __cosh_finite F
+ __coshf_finite F
+ __exp10_finite F
+ __exp10f_finite F
+ __exp2_finite F
+ __exp2f_finite F
+ __exp_finite F
+ __expf_finite F
+ __fmod_finite F
+ __fmodf_finite F
+ __gamma_r_finite F
+ __gammaf_r_finite F
+ __hypot_finite F
+ __hypotf_finite F
+ __j0_finite F
+ __j0f_finite F
+ __j1_finite F
+ __j1f_finite F
+ __jn_finite F
+ __jnf_finite F
+ __lgamma_r_finite F
+ __lgammaf_r_finite F
+ __log10_finite F
+ __log10f_finite F
+ __log2_finite F
+ __log2f_finite F
+ __log_finite F
+ __logf_finite F
+ __pow_finite F
+ __powf_finite F
+ __remainder_finite F
+ __remainderf_finite F
+ __scalb_finite F
+ __scalbf_finite F
+ __sinh_finite F
+ __sinhf_finite F
+ __sqrt_finite F
+ __sqrtf_finite F
+ __y0_finite F
+ __y0f_finite F
+ __y1_finite F
+ __y1f_finite F
+ __yn_finite F
+ __ynf_finite F
+GLIBC_2.2
+ GLIBC_2.2 A
+ feclearexcept F
+ fedisableexcept F
+ feenableexcept F
+ fegetenv F
+ fegetexcept F
+ fegetexceptflag F
+ feraiseexcept F
+ fesetenv F
+ fesetexceptflag F
+ feupdateenv F
+GLIBC_2.4
+ GLIBC_2.4 A
+ exp2l F
--- /dev/null
+++ eglibc-2.18/ports/sysdeps/unix/sysv/linux/or1k/nptl/vfork.c
@@ -0,0 +1,30 @@
+/* Copyright (C) 1992, 1995, 1997, 2000, 2002 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <errno.h>
+#include <unistd.h>
+
+/* If we don't have vfork, fork is close enough.  */
+
+__pid_t
+__vfork (void)
+{
+  return __fork ();
+}
+libc_hidden_def (__vfork)
+
+weak_alias (__vfork, vfork)
--- /dev/null
+++ eglibc-2.18/ports/sysdeps/unix/sysv/linux/or1k/nptl/libpthread.abilist
@@ -0,0 +1,267 @@
+GLIBC_2.0
+ GLIBC_2.0 A
+ _IO_flockfile F
+ _IO_ftrylockfile F
+ _IO_funlockfile F
+ __close F
+ __connect F
+ __errno_location F
+ __fcntl F
+ __fork F
+ __h_errno_location F
+ __lseek F
+ __open F
+ __pthread_getspecific F
+ __pthread_key_create F
+ __pthread_mutex_destroy F
+ __pthread_mutex_init F
+ __pthread_mutex_lock F
+ __pthread_mutex_trylock F
+ __pthread_mutex_unlock F
+ __pthread_mutexattr_destroy F
+ __pthread_mutexattr_init F
+ __pthread_mutexattr_settype F
+ __pthread_once F
+ __pthread_setspecific F
+ __read F
+ __send F
+ __sigaction F
+ __wait F
+ __write F
+ _pthread_cleanup_pop F
+ _pthread_cleanup_pop_restore F
+ _pthread_cleanup_push F
+ _pthread_cleanup_push_defer F
+ accept F
+ close F
+ connect F
+ fcntl F
+ flockfile F
+ fork F
+ fsync F
+ ftrylockfile F
+ funlockfile F
+ longjmp F
+ lseek F
+ msync F
+ nanosleep F
+ open F
+ pause F
+ pthread_atfork F
+ pthread_attr_destroy F
+ pthread_attr_getdetachstate F
+ pthread_attr_getinheritsched F
+ pthread_attr_getschedparam F
+ pthread_attr_getschedpolicy F
+ pthread_attr_getscope F
+ pthread_attr_init F
+ pthread_attr_setdetachstate F
+ pthread_attr_setinheritsched F
+ pthread_attr_setschedparam F
+ pthread_attr_setschedpolicy F
+ pthread_attr_setscope F
+ pthread_cancel F
+ pthread_cond_broadcast F
+ pthread_cond_destroy F
+ pthread_cond_init F
+ pthread_cond_signal F
+ pthread_cond_timedwait F
+ pthread_cond_wait F
+ pthread_condattr_destroy F
+ pthread_condattr_init F
+ pthread_create F
+ pthread_detach F
+ pthread_equal F
+ pthread_exit F
+ pthread_getschedparam F
+ pthread_getspecific F
+ pthread_join F
+ pthread_key_create F
+ pthread_key_delete F
+ pthread_kill F
+ pthread_kill_other_threads_np F
+ pthread_mutex_destroy F
+ pthread_mutex_init F
+ pthread_mutex_lock F
+ pthread_mutex_trylock F
+ pthread_mutex_unlock F
+ pthread_mutexattr_destroy F
+ pthread_mutexattr_getkind_np F
+ pthread_mutexattr_init F
+ pthread_mutexattr_setkind_np F
+ pthread_once F
+ pthread_self F
+ pthread_setcancelstate F
+ pthread_setcanceltype F
+ pthread_setschedparam F
+ pthread_setspecific F
+ pthread_sigmask F
+ pthread_testcancel F
+ raise F
+ read F
+ recv F
+ recvfrom F
+ recvmsg F
+ sem_destroy F
+ sem_getvalue F
+ sem_init F
+ sem_post F
+ sem_trywait F
+ sem_wait F
+ send F
+ sendmsg F
+ sendto F
+ sigaction F
+ siglongjmp F
+ sigwait F
+ system F
+ tcdrain F
+ vfork F
+ wait F
+ waitpid F
+ write F
+GLIBC_2.1
+ GLIBC_2.1 A
+ __libc_allocate_rtsig F
+ __libc_current_sigrtmax F
+ __libc_current_sigrtmin F
+ pthread_attr_getguardsize F
+ pthread_attr_getstackaddr F
+ pthread_attr_getstacksize F
+ pthread_attr_init F
+ pthread_attr_setguardsize F
+ pthread_attr_setstackaddr F
+ pthread_attr_setstacksize F
+ pthread_create F
+ pthread_getconcurrency F
+ pthread_mutexattr_gettype F
+ pthread_mutexattr_settype F
+ pthread_rwlock_destroy F
+ pthread_rwlock_init F
+ pthread_rwlock_rdlock F
+ pthread_rwlock_tryrdlock F
+ pthread_rwlock_trywrlock F
+ pthread_rwlock_unlock F
+ pthread_rwlock_wrlock F
+ pthread_rwlockattr_destroy F
+ pthread_rwlockattr_getkind_np F
+ pthread_rwlockattr_getpshared F
+ pthread_rwlockattr_init F
+ pthread_rwlockattr_setkind_np F
+ pthread_rwlockattr_setpshared F
+ pthread_setconcurrency F
+ sem_destroy F
+ sem_getvalue F
+ sem_init F
+ sem_post F
+ sem_trywait F
+ sem_wait F
+GLIBC_2.1.1
+ GLIBC_2.1.1 A
+ sem_close F
+ sem_open F
+ sem_unlink F
+GLIBC_2.1.2
+ GLIBC_2.1.2 A
+ __vfork F
+GLIBC_2.11
+ GLIBC_2.11 A
+ pthread_sigqueue F
+GLIBC_2.12
+ GLIBC_2.12 A
+ pthread_getname_np F
+ pthread_mutex_consistent F
+ pthread_mutexattr_getrobust F
+ pthread_mutexattr_setrobust F
+ pthread_setname_np F
+GLIBC_2.2
+ GLIBC_2.2 A
+ __open64 F
+ __pread64 F
+ __pthread_rwlock_destroy F
+ __pthread_rwlock_init F
+ __pthread_rwlock_rdlock F
+ __pthread_rwlock_tryrdlock F
+ __pthread_rwlock_trywrlock F
+ __pthread_rwlock_unlock F
+ __pthread_rwlock_wrlock F
+ __pwrite64 F
+ __res_state F
+ lseek64 F
+ open64 F
+ pread F
+ pread64 F
+ pthread_attr_getstack F
+ pthread_attr_setstack F
+ pthread_barrier_destroy F
+ pthread_barrier_init F
+ pthread_barrier_wait F
+ pthread_barrierattr_destroy F
+ pthread_barrierattr_init F
+ pthread_barrierattr_setpshared F
+ pthread_condattr_getpshared F
+ pthread_condattr_setpshared F
+ pthread_getcpuclockid F
+ pthread_mutex_timedlock F
+ pthread_mutexattr_getpshared F
+ pthread_mutexattr_setpshared F
+ pthread_rwlock_timedrdlock F
+ pthread_rwlock_timedwrlock F
+ pthread_spin_destroy F
+ pthread_spin_init F
+ pthread_spin_lock F
+ pthread_spin_trylock F
+ pthread_spin_unlock F
+ pthread_yield F
+ pwrite F
+ pwrite64 F
+ sem_timedwait F
+GLIBC_2.2.3
+ GLIBC_2.2.3 A
+ pthread_getattr_np F
+GLIBC_2.2.6
+ GLIBC_2.2.6 A
+ __nanosleep F
+GLIBC_2.3.2
+ GLIBC_2.3.2 A
+ pthread_cond_broadcast F
+ pthread_cond_destroy F
+ pthread_cond_init F
+ pthread_cond_signal F
+ pthread_cond_timedwait F
+ pthread_cond_wait F
+GLIBC_2.3.3
+ GLIBC_2.3.3 A
+ __pthread_cleanup_routine F
+ __pthread_register_cancel F
+ __pthread_register_cancel_defer F
+ __pthread_unregister_cancel F
+ __pthread_unregister_cancel_restore F
+ __pthread_unwind_next F
+ pthread_attr_getaffinity_np F
+ pthread_attr_setaffinity_np F
+ pthread_barrierattr_getpshared F
+ pthread_condattr_getclock F
+ pthread_condattr_setclock F
+ pthread_getaffinity_np F
+ pthread_setaffinity_np F
+ pthread_timedjoin_np F
+ pthread_tryjoin_np F
+GLIBC_2.3.4
+ GLIBC_2.3.4 A
+ pthread_attr_getaffinity_np F
+ pthread_attr_setaffinity_np F
+ pthread_getaffinity_np F
+ pthread_setaffinity_np F
+ pthread_setschedprio F
+GLIBC_2.4
+ GLIBC_2.4 A
+ pthread_mutex_consistent_np F
+ pthread_mutex_getprioceiling F
+ pthread_mutex_setprioceiling F
+ pthread_mutexattr_getprioceiling F
+ pthread_mutexattr_getprotocol F
+ pthread_mutexattr_getrobust_np F
+ pthread_mutexattr_setprioceiling F
+ pthread_mutexattr_setprotocol F
+ pthread_mutexattr_setrobust_np F
--- /dev/null
+++ eglibc-2.18/ports/sysdeps/unix/sysv/linux/or1k/nptl/pthread_once.c
@@ -0,0 +1,94 @@
+/* Copyright (C) 2011-2012 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Chris Metcalf <cmetcalf@tilera.com>, 2011.
+   Based on work contributed by Jakub Jelinek <jakub@redhat.com>, 2003.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <nptl/pthreadP.h>
+#include <lowlevellock.h>
+
+
+unsigned long int __fork_generation attribute_hidden;
+
+
+static void
+clear_once_control (void *arg)
+{
+  pthread_once_t *once_control = (pthread_once_t *) arg;
+
+  *once_control = 0;
+  lll_futex_wake (once_control, INT_MAX, LLL_PRIVATE);
+}
+
+
+int
+__pthread_once (once_control, init_routine)
+     pthread_once_t *once_control;
+     void (*init_routine) (void);
+{
+  while (1)
+    {
+      int oldval, val, newval;
+
+      val = *once_control;
+      do
+	{
+	  /* Check if the initialized has already been done.  */
+	  if ((val & 2) != 0)
+	    return 0;
+
+	  oldval = val;
+	  newval = (oldval & 3) | __fork_generation | 1;
+	  val = atomic_compare_and_exchange_val_acq (once_control, newval,
+						     oldval);
+	}
+      while (__builtin_expect (val != oldval, 0));
+
+      /* Check if another thread already runs the initializer.	*/
+      if ((oldval & 1) != 0)
+	{
+	  /* Check whether the initializer execution was interrupted
+	     by a fork.	 */
+	  if (((oldval ^ newval) & -4) == 0)
+	    {
+	      /* Same generation, some other thread was faster. Wait.  */
+	      lll_futex_wait (once_control, newval, LLL_PRIVATE);
+	      continue;
+	    }
+	}
+
+      /* This thread is the first here.  Do the initialization.
+	 Register a cleanup handler so that in case the thread gets
+	 interrupted the initialization can be restarted.  */
+      pthread_cleanup_push (clear_once_control, once_control);
+
+      init_routine ();
+
+      pthread_cleanup_pop (0);
+
+
+      /* Add one to *once_control.  */
+      atomic_increment (once_control);
+
+      /* Wake up all other threads.  */
+      lll_futex_wake (once_control, INT_MAX, LLL_PRIVATE);
+      break;
+    }
+
+  return 0;
+}
+weak_alias (__pthread_once, pthread_once)
+hidden_def (__pthread_once)
--- /dev/null
+++ eglibc-2.18/ports/sysdeps/unix/sysv/linux/or1k/nptl/libc.abilist
@@ -0,0 +1,2253 @@
+GLIBC_2.0
+ GLIBC_2.0 A
+ _IO_adjust_column F
+ _IO_default_doallocate F
+ _IO_default_finish F
+ _IO_default_pbackfail F
+ _IO_default_uflow F
+ _IO_default_xsgetn F
+ _IO_default_xsputn F
+ _IO_do_write F
+ _IO_doallocbuf F
+ _IO_fclose F
+ _IO_fdopen F
+ _IO_feof F
+ _IO_ferror F
+ _IO_fflush F
+ _IO_fgetpos F
+ _IO_fgets F
+ _IO_file_attach F
+ _IO_file_close F
+ _IO_file_close_it F
+ _IO_file_doallocate F
+ _IO_file_fopen F
+ _IO_file_init F
+ _IO_file_jumps D 0x54
+ _IO_file_open F
+ _IO_file_overflow F
+ _IO_file_read F
+ _IO_file_seek F
+ _IO_file_seekoff F
+ _IO_file_setbuf F
+ _IO_file_stat F
+ _IO_file_sync F
+ _IO_file_underflow F
+ _IO_file_write F
+ _IO_file_xsputn F
+ _IO_flockfile F
+ _IO_flush_all F
+ _IO_flush_all_linebuffered F
+ _IO_fopen F
+ _IO_fprintf F
+ _IO_fputs F
+ _IO_fread F
+ _IO_free_backup_area F
+ _IO_fsetpos F
+ _IO_ftell F
+ _IO_ftrylockfile F
+ _IO_funlockfile F
+ _IO_fwrite F
+ _IO_getc F
+ _IO_getline F
+ _IO_gets F
+ _IO_init F
+ _IO_init_marker F
+ _IO_link_in F
+ _IO_list_all D 0x4
+ _IO_marker_delta F
+ _IO_marker_difference F
+ _IO_padn F
+ _IO_peekc_locked F
+ _IO_popen F
+ _IO_printf F
+ _IO_proc_close F
+ _IO_proc_open F
+ _IO_putc F
+ _IO_puts F
+ _IO_remove_marker F
+ _IO_seekmark F
+ _IO_seekoff F
+ _IO_seekpos F
+ _IO_setb F
+ _IO_setbuffer F
+ _IO_setvbuf F
+ _IO_sgetn F
+ _IO_sprintf F
+ _IO_sputbackc F
+ _IO_sscanf F
+ _IO_stderr_ D 0x50
+ _IO_stdin_ D 0x50
+ _IO_stdout_ D 0x50
+ _IO_str_init_readonly F
+ _IO_str_init_static F
+ _IO_str_overflow F
+ _IO_str_pbackfail F
+ _IO_str_seekoff F
+ _IO_str_underflow F
+ _IO_sungetc F
+ _IO_switch_to_get_mode F
+ _IO_un_link F
+ _IO_ungetc F
+ _IO_unsave_markers F
+ _IO_vfprintf F
+ _IO_vfscanf F
+ _IO_vsprintf F
+ ___brk_addr D 0x4
+ __adjtimex F
+ __after_morecore_hook D 0x4
+ __argz_count F
+ __argz_next F
+ __argz_stringify F
+ __assert_fail F
+ __assert_perror_fail F
+ __bsd_getpgrp F
+ __bzero F
+ __check_rhosts_file D 0x4
+ __clone F
+ __close F
+ __cmsg_nxthdr F
+ __connect F
+ __ctype32_b D 0x4
+ __ctype_b D 0x4
+ __ctype_get_mb_cur_max F
+ __ctype_tolower D 0x4
+ __ctype_toupper D 0x4
+ __curbrk D 0x4
+ __daylight D 0x4
+ __dcgettext F
+ __default_morecore F
+ __dgettext F
+ __dup2 F
+ __environ D 0x4
+ __errno_location F
+ __fcntl F
+ __ffs F
+ __finite F
+ __finitef F
+ __finitel F
+ __fork F
+ __fpu_control D 0x4
+ __free_hook D 0x4
+ __fxstat F
+ __getdelim F
+ __getpagesize F
+ __getpgid F
+ __getpid F
+ __gettimeofday F
+ __gmtime_r F
+ __h_errno_location F
+ __isinf F
+ __isinff F
+ __isinfl F
+ __isnan F
+ __isnanf F
+ __isnanl F
+ __iswctype F
+ __ivaliduser F
+ __libc_calloc F
+ __libc_free F
+ __libc_init_first F
+ __libc_mallinfo F
+ __libc_malloc F
+ __libc_mallopt F
+ __libc_memalign F
+ __libc_pvalloc F
+ __libc_realloc F
+ __libc_start_main F
+ __libc_valloc F
+ __lseek F
+ __lxstat F
+ __malloc_hook D 0x4
+ __malloc_initialize_hook D 0x4
+ __mbrlen F
+ __mbrtowc F
+ __memalign_hook D 0x4
+ __mempcpy F
+ __monstartup F
+ __morecore D 0x4
+ __nss_configure_lookup F
+ __nss_database_lookup F
+ __nss_group_lookup F
+ __nss_hosts_lookup F
+ __nss_next F
+ __nss_passwd_lookup F
+ __open F
+ __overflow F
+ __pipe F
+ __printf_fp F
+ __profile_frequency F
+ __progname D 0x4
+ __progname_full D 0x4
+ __rcmd_errstr D 0x4
+ __read F
+ __realloc_hook D 0x4
+ __res_randomid F
+ __sbrk F
+ __sched_get_priority_max F
+ __sched_get_priority_min F
+ __sched_getparam F
+ __sched_getscheduler F
+ __sched_setscheduler F
+ __sched_yield F
+ __secure_getenv F
+ __select F
+ __setpgid F
+ __sigaction F
+ __sigaddset F
+ __sigdelset F
+ __sigismember F
+ __sigpause F
+ __sigsetjmp F
+ __stpcpy F
+ __stpncpy F
+ __strcasecmp F
+ __strdup F
+ __strerror_r F
+ __strtod_internal F
+ __strtof_internal F
+ __strtok_r F
+ __strtol_internal F
+ __strtold_internal F
+ __strtoll_internal F
+ __strtoq_internal F
+ __strtoul_internal F
+ __strtoull_internal F
+ __strtouq_internal F
+ __sysv_signal F
+ __timezone D 0x4
+ __tzname D 0x8
+ __uflow F
+ __underflow F
+ __vfscanf F
+ __vsnprintf F
+ __vsscanf F
+ __wait F
+ __waitpid F
+ __wcstod_internal F
+ __wcstof_internal F
+ __wcstol_internal F
+ __wcstold_internal F
+ __wcstoll_internal F
+ __wcstoul_internal F
+ __wcstoull_internal F
+ __write F
+ __xmknod F
+ __xpg_basename F
+ __xstat F
+ _environ D 0x4
+ _exit F
+ _libc_intl_domainname D 0x5
+ _longjmp F
+ _mcleanup F
+ _mcount F
+ _nl_default_dirname D 0x12
+ _nl_domain_bindings D 0x4
+ _nl_msg_cat_cntr D 0x4
+ _null_auth D 0xc
+ _obstack D 0x4
+ _obstack_allocated_p F
+ _obstack_begin F
+ _obstack_begin_1 F
+ _obstack_free F
+ _obstack_memory_used F
+ _obstack_newchunk F
+ _res D 0x200
+ _rpc_dtablesize F
+ _seterr_reply F
+ _setjmp F
+ _sys_errlist D 0x1ec
+ _sys_nerr D 0x4
+ _sys_siglist D 0x80
+ _tolower F
+ _toupper F
+ a64l F
+ abort F
+ abs F
+ accept F
+ access F
+ acct F
+ addmntent F
+ adjtime F
+ adjtimex F
+ advance F
+ alarm F
+ alphasort F
+ argz_add F
+ argz_add_sep F
+ argz_append F
+ argz_count F
+ argz_create F
+ argz_create_sep F
+ argz_delete F
+ argz_extract F
+ argz_insert F
+ argz_next F
+ argz_replace F
+ argz_stringify F
+ asctime F
+ asctime_r F
+ asprintf F
+ atexit F
+ atof F
+ atoi F
+ atol F
+ atoll F
+ authnone_create F
+ authunix_create F
+ authunix_create_default F
+ basename F
+ bcmp F
+ bcopy F
+ bdflush F
+ bind F
+ bindresvport F
+ bindtextdomain F
+ brk F
+ bsd_signal F
+ bsearch F
+ btowc F
+ bzero F
+ calloc F
+ callrpc F
+ canonicalize_file_name F
+ catclose F
+ catgets F
+ catopen F
+ cfgetispeed F
+ cfgetospeed F
+ cfmakeraw F
+ cfree F
+ cfsetispeed F
+ cfsetospeed F
+ cfsetspeed F
+ chdir F
+ chflags F
+ chmod F
+ chown F
+ chroot F
+ clearenv F
+ clearerr F
+ clearerr_unlocked F
+ clnt_broadcast F
+ clnt_create F
+ clnt_pcreateerror F
+ clnt_perrno F
+ clnt_perror F
+ clnt_spcreateerror F
+ clnt_sperrno F
+ clnt_sperror F
+ clntraw_create F
+ clnttcp_create F
+ clntudp_bufcreate F
+ clntudp_create F
+ clock F
+ clone F
+ close F
+ closedir F
+ closelog F
+ confstr F
+ connect F
+ copysign F
+ copysignf F
+ copysignl F
+ creat F
+ create_module F
+ ctermid F
+ ctime F
+ ctime_r F
+ cuserid F
+ daemon F
+ daylight D 0x4
+ dcgettext F
+ delete_module F
+ dgettext F
+ difftime F
+ dirfd F
+ dirname F
+ div F
+ dprintf F
+ drand48 F
+ drand48_r F
+ dup F
+ dup2 F
+ dysize F
+ ecvt F
+ ecvt_r F
+ endaliasent F
+ endfsent F
+ endgrent F
+ endhostent F
+ endmntent F
+ endnetent F
+ endnetgrent F
+ endprotoent F
+ endpwent F
+ endrpcent F
+ endservent F
+ endspent F
+ endttyent F
+ endusershell F
+ endutent F
+ environ D 0x4
+ envz_add F
+ envz_entry F
+ envz_get F
+ envz_merge F
+ envz_remove F
+ envz_strip F
+ erand48 F
+ erand48_r F
+ err F
+ error F
+ error_at_line F
+ error_message_count D 0x4
+ error_one_per_line D 0x4
+ error_print_progname D 0x4
+ errx F
+ ether_aton F
+ ether_aton_r F
+ ether_hostton F
+ ether_line F
+ ether_ntoa F
+ ether_ntoa_r F
+ ether_ntohost F
+ euidaccess F
+ execl F
+ execle F
+ execlp F
+ execv F
+ execve F
+ execvp F
+ exit F
+ fchdir F
+ fchflags F
+ fchmod F
+ fchown F
+ fclose F
+ fcloseall F
+ fcntl F
+ fcvt F
+ fcvt_r F
+ fdatasync F
+ fdopen F
+ feof F
+ feof_unlocked F
+ ferror F
+ ferror_unlocked F
+ fexecve F
+ fflush F
+ fflush_unlocked F
+ ffs F
+ fgetc F
+ fgetgrent F
+ fgetgrent_r F
+ fgetpos F
+ fgetpwent F
+ fgetpwent_r F
+ fgets F
+ fgetspent F
+ fgetspent_r F
+ fileno F
+ fileno_unlocked F
+ finite F
+ finitef F
+ finitel F
+ flock F
+ flockfile F
+ fnmatch F
+ fopen F
+ fopencookie F
+ fork F
+ fpathconf F
+ fprintf F
+ fputc F
+ fputc_unlocked F
+ fputs F
+ fread F
+ free F
+ freeaddrinfo F
+ freopen F
+ frexp F
+ frexpf F
+ frexpl F
+ fscanf F
+ fseek F
+ fsetpos F
+ fstatfs F
+ fsync F
+ ftell F
+ ftime F
+ ftok F
+ ftruncate F
+ ftrylockfile F
+ fts_children F
+ fts_close F
+ fts_open F
+ fts_read F
+ fts_set F
+ ftw F
+ funlockfile F
+ fwrite F
+ gcvt F
+ get_avphys_pages F
+ get_current_dir_name F
+ get_kernel_syms F
+ get_myaddress F
+ get_nprocs F
+ get_nprocs_conf F
+ get_phys_pages F
+ getaddrinfo F
+ getaliasbyname F
+ getaliasbyname_r F
+ getaliasent F
+ getaliasent_r F
+ getc F
+ getc_unlocked F
+ getchar F
+ getchar_unlocked F
+ getcwd F
+ getdelim F
+ getdirentries F
+ getdomainname F
+ getdtablesize F
+ getegid F
+ getenv F
+ geteuid F
+ getfsent F
+ getfsfile F
+ getfsspec F
+ getgid F
+ getgrent F
+ getgrent_r F
+ getgrgid F
+ getgrgid_r F
+ getgrnam F
+ getgrnam_r F
+ getgroups F
+ gethostbyaddr F
+ gethostbyaddr_r F
+ gethostbyname F
+ gethostbyname2 F
+ gethostbyname2_r F
+ gethostbyname_r F
+ gethostent F
+ gethostent_r F
+ gethostid F
+ gethostname F
+ getitimer F
+ getline F
+ getlogin F
+ getlogin_r F
+ getmntent F
+ getmntent_r F
+ getnetbyaddr F
+ getnetbyaddr_r F
+ getnetbyname F
+ getnetbyname_r F
+ getnetent F
+ getnetent_r F
+ getnetgrent F
+ getnetgrent_r F
+ getopt F
+ getopt_long F
+ getopt_long_only F
+ getpagesize F
+ getpass F
+ getpeername F
+ getpgid F
+ getpgrp F
+ getpid F
+ getppid F
+ getpriority F
+ getprotobyname F
+ getprotobyname_r F
+ getprotobynumber F
+ getprotobynumber_r F
+ getprotoent F
+ getprotoent_r F
+ getpublickey F
+ getpw F
+ getpwent F
+ getpwent_r F
+ getpwnam F
+ getpwnam_r F
+ getpwuid F
+ getpwuid_r F
+ getresgid F
+ getresuid F
+ getrlimit F
+ getrpcbyname F
+ getrpcbyname_r F
+ getrpcbynumber F
+ getrpcbynumber_r F
+ getrpcent F
+ getrpcent_r F
+ getrpcport F
+ getrusage F
+ gets F
+ getsecretkey F
+ getservbyname F
+ getservbyname_r F
+ getservbyport F
+ getservbyport_r F
+ getservent F
+ getservent_r F
+ getsid F
+ getsockname F
+ getsockopt F
+ getspent F
+ getspent_r F
+ getspnam F
+ getspnam_r F
+ getsubopt F
+ gettext F
+ gettimeofday F
+ getttyent F
+ getttynam F
+ getuid F
+ getusershell F
+ getutent F
+ getutent_r F
+ getutid F
+ getutid_r F
+ getutline F
+ getutline_r F
+ getw F
+ getwd F
+ glob F
+ glob_pattern_p F
+ globfree F
+ gmtime F
+ gmtime_r F
+ group_member F
+ gsignal F
+ gtty F
+ h_errlist D 0x14
+ h_nerr D 0x4
+ hasmntopt F
+ hcreate F
+ hcreate_r F
+ hdestroy F
+ hdestroy_r F
+ herror F
+ hsearch F
+ hsearch_r F
+ hstrerror F
+ htonl F
+ htons F
+ index F
+ inet_addr F
+ inet_aton F
+ inet_lnaof F
+ inet_makeaddr F
+ inet_netof F
+ inet_network F
+ inet_nsap_addr F
+ inet_nsap_ntoa F
+ inet_ntoa F
+ inet_ntop F
+ inet_pton F
+ init_module F
+ initgroups F
+ initstate F
+ initstate_r F
+ innetgr F
+ insque F
+ ioctl F
+ iruserok F
+ isalnum F
+ isalpha F
+ isascii F
+ isatty F
+ isblank F
+ iscntrl F
+ isdigit F
+ isfdtype F
+ isgraph F
+ isinf F
+ isinff F
+ isinfl F
+ islower F
+ isnan F
+ isnanf F
+ isnanl F
+ isprint F
+ ispunct F
+ isspace F
+ isupper F
+ iswalnum F
+ iswalpha F
+ iswcntrl F
+ iswctype F
+ iswdigit F
+ iswgraph F
+ iswlower F
+ iswprint F
+ iswpunct F
+ iswspace F
+ iswupper F
+ iswxdigit F
+ isxdigit F
+ jrand48 F
+ jrand48_r F
+ kill F
+ killpg F
+ klogctl F
+ l64a F
+ labs F
+ lchown F
+ lckpwdf F
+ lcong48 F
+ lcong48_r F
+ ldexp F
+ ldexpf F
+ ldexpl F
+ ldiv F
+ lfind F
+ link F
+ listen F
+ llabs F
+ lldiv F
+ llseek F
+ loc1 D 0x4
+ loc2 D 0x4
+ localeconv F
+ localtime F
+ localtime_r F
+ lockf F
+ locs D 0x4
+ longjmp F
+ lrand48 F
+ lrand48_r F
+ lsearch F
+ lseek F
+ madvise F
+ mallinfo F
+ malloc F
+ malloc_get_state F
+ malloc_set_state F
+ malloc_stats F
+ malloc_trim F
+ malloc_usable_size F
+ mallopt F
+ mallwatch D 0x4
+ mblen F
+ mbrlen F
+ mbrtowc F
+ mbsinit F
+ mbsnrtowcs F
+ mbsrtowcs F
+ mbstowcs F
+ mbtowc F
+ mcheck F
+ mcount F
+ memalign F
+ memccpy F
+ memchr F
+ memcmp F
+ memcpy F
+ memfrob F
+ memmem F
+ memmove F
+ memset F
+ mkdir F
+ mkfifo F
+ mkstemp F
+ mktemp F
+ mktime F
+ mlock F
+ mlockall F
+ mmap F
+ modf F
+ modff F
+ modfl F
+ monstartup F
+ mount F
+ mprobe F
+ mprotect F
+ mrand48 F
+ mrand48_r F
+ mremap F
+ msgctl F
+ msgget F
+ msgrcv F
+ msgsnd F
+ msync F
+ mtrace F
+ munlock F
+ munlockall F
+ munmap F
+ muntrace F
+ nanosleep F
+ nfsservctl F
+ nice F
+ nl_langinfo F
+ nrand48 F
+ nrand48_r F
+ ntohl F
+ ntohs F
+ obstack_alloc_failed_handler D 0x4
+ obstack_exit_failure D 0x4
+ obstack_free F
+ obstack_printf F
+ obstack_vprintf F
+ on_exit F
+ open F
+ open_memstream F
+ opendir F
+ openlog F
+ optarg D 0x4
+ opterr D 0x4
+ optind D 0x4
+ optopt D 0x4
+ parse_printf_format F
+ pathconf F
+ pause F
+ pclose F
+ perror F
+ personality F
+ pipe F
+ pmap_getmaps F
+ pmap_getport F
+ pmap_rmtcall F
+ pmap_set F
+ pmap_unset F
+ poll F
+ popen F
+ prctl F
+ printf F
+ profil F
+ program_invocation_name D 0x4
+ program_invocation_short_name D 0x4
+ pselect F
+ psignal F
+ pthread_attr_destroy F
+ pthread_attr_getdetachstate F
+ pthread_attr_getinheritsched F
+ pthread_attr_getschedparam F
+ pthread_attr_getschedpolicy F
+ pthread_attr_getscope F
+ pthread_attr_init F
+ pthread_attr_setdetachstate F
+ pthread_attr_setinheritsched F
+ pthread_attr_setschedparam F
+ pthread_attr_setschedpolicy F
+ pthread_attr_setscope F
+ pthread_cond_broadcast F
+ pthread_cond_destroy F
+ pthread_cond_init F
+ pthread_cond_signal F
+ pthread_cond_timedwait F
+ pthread_cond_wait F
+ pthread_condattr_destroy F
+ pthread_condattr_init F
+ pthread_equal F
+ pthread_exit F
+ pthread_getschedparam F
+ pthread_mutex_destroy F
+ pthread_mutex_init F
+ pthread_mutex_lock F
+ pthread_mutex_unlock F
+ pthread_self F
+ pthread_setcancelstate F
+ pthread_setcanceltype F
+ pthread_setschedparam F
+ ptrace F
+ putc F
+ putc_unlocked F
+ putchar F
+ putchar_unlocked F
+ putenv F
+ putpwent F
+ puts F
+ putspent F
+ pututline F
+ putw F
+ pvalloc F
+ qecvt F
+ qecvt_r F
+ qfcvt F
+ qfcvt_r F
+ qgcvt F
+ qsort F
+ query_module F
+ quotactl F
+ raise F
+ rand F
+ rand_r F
+ random F
+ random_r F
+ rcmd F
+ re_comp F
+ re_compile_fastmap F
+ re_compile_pattern F
+ re_exec F
+ re_match F
+ re_match_2 F
+ re_max_failures D 0x4
+ re_search F
+ re_search_2 F
+ re_set_registers F
+ re_set_syntax F
+ re_syntax_options D 0x4
+ read F
+ readdir F
+ readdir_r F
+ readlink F
+ readv F
+ realloc F
+ realpath F
+ reboot F
+ recv F
+ recvfrom F
+ recvmsg F
+ regcomp F
+ regerror F
+ regexec F
+ regfree F
+ register_printf_function F
+ registerrpc F
+ remove F
+ remque F
+ rename F
+ res_init F
+ revoke F
+ rewind F
+ rewinddir F
+ rexec F
+ rexecoptions D 0x4
+ rindex F
+ rmdir F
+ rpc_createerr D 0x10
+ rpmatch F
+ rresvport F
+ ruserok F
+ ruserpass F
+ sbrk F
+ scalbn F
+ scalbnf F
+ scalbnl F
+ scandir F
+ scanf F
+ sched_get_priority_max F
+ sched_get_priority_min F
+ sched_getparam F
+ sched_getscheduler F
+ sched_rr_get_interval F
+ sched_setparam F
+ sched_setscheduler F
+ sched_yield F
+ seed48 F
+ seed48_r F
+ seekdir F
+ select F
+ semget F
+ semop F
+ send F
+ sendmsg F
+ sendto F
+ setaliasent F
+ setbuf F
+ setbuffer F
+ setcontext F
+ setdomainname F
+ setegid F
+ setenv F
+ seteuid F
+ setfsent F
+ setfsgid F
+ setfsuid F
+ setgid F
+ setgrent F
+ setgroups F
+ sethostent F
+ sethostid F
+ sethostname F
+ setitimer F
+ setjmp F
+ setlinebuf F
+ setlocale F
+ setlogin F
+ setlogmask F
+ setmntent F
+ setnetent F
+ setnetgrent F
+ setpgid F
+ setpgrp F
+ setpriority F
+ setprotoent F
+ setpwent F
+ setregid F
+ setresgid F
+ setresuid F
+ setreuid F
+ setrlimit F
+ setrpcent F
+ setservent F
+ setsid F
+ setsockopt F
+ setspent F
+ setstate F
+ setstate_r F
+ settimeofday F
+ setttyent F
+ setuid F
+ setusershell F
+ setutent F
+ setvbuf F
+ sgetspent F
+ sgetspent_r F
+ shmat F
+ shmctl F
+ shmdt F
+ shmget F
+ shutdown F
+ sigaction F
+ sigaddset F
+ sigaltstack F
+ sigandset F
+ sigblock F
+ sigdelset F
+ sigemptyset F
+ sigfillset F
+ siggetmask F
+ siginterrupt F
+ sigisemptyset F
+ sigismember F
+ siglongjmp F
+ signal F
+ sigorset F
+ sigpause F
+ sigpending F
+ sigprocmask F
+ sigreturn F
+ sigsetmask F
+ sigstack F
+ sigsuspend F
+ sigvec F
+ sigwait F
+ sleep F
+ snprintf F
+ socket F
+ socketpair F
+ sprintf F
+ srand F
+ srand48 F
+ srand48_r F
+ srandom F
+ srandom_r F
+ sscanf F
+ ssignal F
+ sstk F
+ statfs F
+ stderr D 0x4
+ stdin D 0x4
+ stdout D 0x4
+ step F
+ stime F
+ stpcpy F
+ stpncpy F
+ strcasecmp F
+ strcat F
+ strchr F
+ strcmp F
+ strcoll F
+ strcpy F
+ strcspn F
+ strdup F
+ strerror F
+ strerror_r F
+ strfmon F
+ strfry F
+ strftime F
+ strlen F
+ strncasecmp F
+ strncat F
+ strncmp F
+ strncpy F
+ strndup F
+ strnlen F
+ strpbrk F
+ strptime F
+ strrchr F
+ strsep F
+ strsignal F
+ strspn F
+ strstr F
+ strtod F
+ strtof F
+ strtok F
+ strtok_r F
+ strtol F
+ strtold F
+ strtoll F
+ strtoq F
+ strtoul F
+ strtoull F
+ strtouq F
+ strxfrm F
+ stty F
+ svc_exit F
+ svc_fdset D 0x80
+ svc_getreq F
+ svc_getreqset F
+ svc_register F
+ svc_run F
+ svc_sendreply F
+ svc_unregister F
+ svcauthdes_stats D 0xc
+ svcerr_auth F
+ svcerr_decode F
+ svcerr_noproc F
+ svcerr_noprog F
+ svcerr_progvers F
+ svcerr_systemerr F
+ svcerr_weakauth F
+ svcfd_create F
+ svcraw_create F
+ svctcp_create F
+ svcudp_bufcreate F
+ svcudp_create F
+ svcudp_enablecache F
+ swab F
+ swapoff F
+ swapon F
+ symlink F
+ sync F
+ sys_errlist D 0x1ec
+ sys_nerr D 0x4
+ sys_sigabbrev D 0x80
+ sys_siglist D 0x80
+ syscall F
+ sysconf F
+ sysctl F
+ sysinfo F
+ syslog F
+ system F
+ tcdrain F
+ tcflow F
+ tcflush F
+ tcgetattr F
+ tcgetpgrp F
+ tcsendbreak F
+ tcsetattr F
+ tcsetpgrp F
+ tdelete F
+ telldir F
+ tempnam F
+ textdomain F
+ tfind F
+ time F
+ timegm F
+ timelocal F
+ times F
+ timezone D 0x4
+ tmpfile F
+ tmpnam F
+ tmpnam_r F
+ toascii F
+ tolower F
+ toupper F
+ towctrans F
+ towlower F
+ towupper F
+ tr_break F
+ truncate F
+ tsearch F
+ ttyname F
+ ttyname_r F
+ ttyslot F
+ twalk F
+ tzname D 0x8
+ tzset F
+ ualarm F
+ ulckpwdf F
+ ulimit F
+ umask F
+ umount F
+ uname F
+ ungetc F
+ unlink F
+ unsetenv F
+ updwtmp F
+ uselib F
+ usleep F
+ ustat F
+ utime F
+ utimes F
+ utmpname F
+ valloc F
+ vasprintf F
+ vdprintf F
+ verr F
+ verrx F
+ vfork F
+ vfprintf F
+ vfscanf F
+ vhangup F
+ vlimit F
+ vprintf F
+ vscanf F
+ vsnprintf F
+ vsprintf F
+ vsscanf F
+ vsyslog F
+ vtimes F
+ vwarn F
+ vwarnx F
+ wait F
+ wait3 F
+ wait4 F
+ waitpid F
+ warn F
+ warnx F
+ wcpcpy F
+ wcpncpy F
+ wcrtomb F
+ wcscat F
+ wcschr F
+ wcscmp F
+ wcscoll F
+ wcscpy F
+ wcscspn F
+ wcsdup F
+ wcslen F
+ wcsncat F
+ wcsncmp F
+ wcsncpy F
+ wcsnrtombs F
+ wcspbrk F
+ wcsrchr F
+ wcsrtombs F
+ wcsspn F
+ wcsstr F
+ wcstod F
+ wcstof F
+ wcstok F
+ wcstol F
+ wcstold F
+ wcstombs F
+ wcstoq F
+ wcstoul F
+ wcstouq F
+ wcswidth F
+ wcsxfrm F
+ wctob F
+ wctomb F
+ wctrans F
+ wctype F
+ wcwidth F
+ wmemchr F
+ wmemcmp F
+ wmemcpy F
+ wmemmove F
+ wmemset F
+ write F
+ writev F
+ xdr_accepted_reply F
+ xdr_array F
+ xdr_authunix_parms F
+ xdr_bool F
+ xdr_bytes F
+ xdr_callhdr F
+ xdr_callmsg F
+ xdr_char F
+ xdr_cryptkeyarg F
+ xdr_cryptkeyarg2 F
+ xdr_cryptkeyres F
+ xdr_des_block F
+ xdr_double F
+ xdr_enum F
+ xdr_float F
+ xdr_free F
+ xdr_int F
+ xdr_key_netstarg F
+ xdr_key_netstres F
+ xdr_keybuf F
+ xdr_keystatus F
+ xdr_long F
+ xdr_netobj F
+ xdr_opaque F
+ xdr_opaque_auth F
+ xdr_pmap F
+ xdr_pmaplist F
+ xdr_pointer F
+ xdr_reference F
+ xdr_rejected_reply F
+ xdr_replymsg F
+ xdr_rmtcall_args F
+ xdr_rmtcallres F
+ xdr_short F
+ xdr_string F
+ xdr_u_char F
+ xdr_u_int F
+ xdr_u_long F
+ xdr_u_short F
+ xdr_union F
+ xdr_vector F
+ xdr_void F
+ xdr_wrapstring F
+ xdrmem_create F
+ xdrrec_create F
+ xdrrec_endofrecord F
+ xdrrec_eof F
+ xdrrec_skiprecord F
+ xdrstdio_create F
+ xencrypt F
+ xprt_register F
+ xprt_unregister F
+GLIBC_2.1
+ GLIBC_2.1 A
+ _IO_2_1_stderr_ D 0x98
+ _IO_2_1_stdin_ D 0x98
+ _IO_2_1_stdout_ D 0x98
+ _IO_do_write F
+ _IO_fclose F
+ _IO_fdopen F
+ _IO_fgetpos64 F
+ _IO_file_attach F
+ _IO_file_close_it F
+ _IO_file_finish F
+ _IO_file_fopen F
+ _IO_file_init F
+ _IO_file_overflow F
+ _IO_file_seekoff F
+ _IO_file_setbuf F
+ _IO_file_sync F
+ _IO_file_underflow F
+ _IO_file_write F
+ _IO_file_xsputn F
+ _IO_fopen F
+ _IO_fsetpos64 F
+ _IO_getline_info F
+ _IO_popen F
+ _IO_proc_close F
+ _IO_proc_open F
+ __asprintf F
+ __backtrace F
+ __backtrace_symbols F
+ __backtrace_symbols_fd F
+ __duplocale F
+ __freelocale F
+ __fxstat64 F
+ __isalnum_l F
+ __isalpha_l F
+ __isascii_l F
+ __isblank_l F
+ __iscntrl_l F
+ __isdigit_l F
+ __isgraph_l F
+ __islower_l F
+ __isprint_l F
+ __ispunct_l F
+ __isspace_l F
+ __isupper_l F
+ __iswalnum_l F
+ __iswalpha_l F
+ __iswblank_l F
+ __iswcntrl_l F
+ __iswctype_l F
+ __iswdigit_l F
+ __iswgraph_l F
+ __iswlower_l F
+ __iswprint_l F
+ __iswpunct_l F
+ __iswspace_l F
+ __iswupper_l F
+ __iswxdigit_l F
+ __isxdigit_l F
+ __key_decryptsession_pk_LOCAL D 0x4
+ __key_encryptsession_pk_LOCAL D 0x4
+ __key_gendes_LOCAL D 0x4
+ __libc_allocate_rtsig F
+ __libc_current_sigrtmax F
+ __libc_current_sigrtmin F
+ __libc_freeres F
+ __libc_sa_len F
+ __lxstat64 F
+ __newlocale F
+ __poll F
+ __pread64 F
+ __pwrite64 F
+ __rawmemchr F
+ __signbit F
+ __signbitf F
+ __strcasecmp_l F
+ __strcasestr F
+ __strcoll_l F
+ __strfmon_l F
+ __strncasecmp_l F
+ __strtod_l F
+ __strtof_l F
+ __strtol_l F
+ __strtold_l F
+ __strtoll_l F
+ __strtoul_l F
+ __strtoull_l F
+ __strxfrm_l F
+ __toascii_l F
+ __tolower_l F
+ __toupper_l F
+ __towctrans F
+ __towctrans_l F
+ __towlower_l F
+ __towupper_l F
+ __wcscasecmp_l F
+ __wcscoll_l F
+ __wcsncasecmp_l F
+ __wcstod_l F
+ __wcstof_l F
+ __wcstol_l F
+ __wcstold_l F
+ __wcstoll_l F
+ __wcstoul_l F
+ __wcstoull_l F
+ __wcsxfrm_l F
+ __wctype_l F
+ __xstat64 F
+ _authenticate F
+ _dl_mcount_wrapper F
+ _dl_mcount_wrapper_check F
+ _sys_errlist D 0x1f4
+ _sys_nerr D 0x4
+ _sys_siglist D 0x100
+ addseverity F
+ alphasort64 F
+ argp_err_exit_status D 0x4
+ argp_error F
+ argp_failure F
+ argp_help F
+ argp_parse F
+ argp_program_bug_address D 0x4
+ argp_program_version D 0x4
+ argp_program_version_hook D 0x4
+ argp_state_help F
+ argp_usage F
+ authdes_create F
+ authdes_getucred F
+ authdes_pk_create F
+ backtrace F
+ backtrace_symbols F
+ backtrace_symbols_fd F
+ capget F
+ capset F
+ cbc_crypt F
+ clntunix_create F
+ creat64 F
+ des_setparity F
+ ecb_crypt F
+ endutxent F
+ fattach F
+ fclose F
+ fdetach F
+ fdopen F
+ ffsl F
+ ffsll F
+ fgetc_unlocked F
+ fgetpos64 F
+ fgets_unlocked F
+ fmtmsg F
+ fopen F
+ fopen64 F
+ fputs_unlocked F
+ fread_unlocked F
+ freopen64 F
+ fseeko F
+ fseeko64 F
+ fsetpos64 F
+ fstatfs64 F
+ fstatvfs F
+ fstatvfs64 F
+ ftello F
+ ftello64 F
+ ftruncate64 F
+ ftw64 F
+ fwrite_unlocked F
+ gai_strerror F
+ getcontext F
+ getdate F
+ getdate_err D 0x4
+ getdate_r F
+ getmsg F
+ getnameinfo F
+ getnetname F
+ getpmsg F
+ getpt F
+ getrlimit64 F
+ getutxent F
+ getutxid F
+ getutxline F
+ glob64 F
+ globfree64 F
+ gnu_get_libc_release F
+ gnu_get_libc_version F
+ grantpt F
+ host2netname F
+ iconv F
+ iconv_close F
+ iconv_open F
+ if_freenameindex F
+ if_indextoname F
+ if_nameindex F
+ if_nametoindex F
+ in6addr_any D 0x10
+ in6addr_loopback D 0x10
+ isastream F
+ iswblank F
+ key_decryptsession F
+ key_decryptsession_pk F
+ key_encryptsession F
+ key_encryptsession_pk F
+ key_gendes F
+ key_get_conv F
+ key_secretkey_is_set F
+ key_setnet F
+ key_setsecret F
+ lockf64 F
+ lseek64 F
+ makecontext F
+ mempcpy F
+ mmap64 F
+ netname2host F
+ netname2user F
+ nftw F
+ nftw64 F
+ ntp_adjtime F
+ ntp_gettime F
+ open64 F
+ passwd2des F
+ pclose F
+ popen F
+ pread F
+ pread64 F
+ printf_size F
+ printf_size_info F
+ pthread_attr_init F
+ ptsname F
+ ptsname_r F
+ putgrent F
+ putmsg F
+ putpmsg F
+ pututxline F
+ pwrite F
+ pwrite64 F
+ rawmemchr F
+ readdir64 F
+ readdir64_r F
+ rtime F
+ scandir64 F
+ sendfile F
+ setrlimit64 F
+ setutxent F
+ sighold F
+ sigignore F
+ sigqueue F
+ sigrelse F
+ sigset F
+ sigtimedwait F
+ sigwaitinfo F
+ statfs64 F
+ statvfs F
+ statvfs64 F
+ strcasestr F
+ strtoimax F
+ strtoumax F
+ strverscmp F
+ svcunix_create F
+ svcunixfd_create F
+ swapcontext F
+ sys_errlist D 0x1f4
+ sys_nerr D 0x4
+ sys_sigabbrev D 0x100
+ sys_siglist D 0x100
+ sysv_signal F
+ tcgetsid F
+ tdestroy F
+ tmpfile F
+ tmpfile64 F
+ truncate64 F
+ umount2 F
+ unlockpt F
+ updwtmpx F
+ user2netname F
+ utmpxname F
+ versionsort F
+ versionsort64 F
+ waitid F
+ wcscasecmp F
+ wcsncasecmp F
+ wcsnlen F
+ wcstoimax F
+ wcstoll F
+ wcstoull F
+ wcstoumax F
+ wcswcs F
+ wordexp F
+ wordfree F
+ xdecrypt F
+ xdr_authdes_cred F
+ xdr_authdes_verf F
+ xdr_getcredres F
+ xdr_int16_t F
+ xdr_int32_t F
+ xdr_int8_t F
+ xdr_netnamestr F
+ xdr_sizeof F
+ xdr_uint16_t F
+ xdr_uint32_t F
+ xdr_uint8_t F
+ xdr_unixcred F
+GLIBC_2.1.1
+ GLIBC_2.1.1 A
+ _Exit F
+ __mempcpy_small F
+ __stpcpy_small F
+ __strcpy_small F
+ __strcspn_c1 F
+ __strcspn_c2 F
+ __strcspn_c3 F
+ __strpbrk_c2 F
+ __strpbrk_c3 F
+ __strsep_1c F
+ __strsep_2c F
+ __strsep_3c F
+ __strsep_g F
+ __strspn_c1 F
+ __strspn_c2 F
+ __strspn_c3 F
+ __strtok_r_1c F
+ __strverscmp F
+ getutmp F
+ getutmpx F
+ imaxabs F
+ imaxdiv F
+ strchrnul F
+ xdr_hyper F
+ xdr_int64_t F
+ xdr_longlong_t F
+ xdr_u_hyper F
+ xdr_u_longlong_t F
+ xdr_uint64_t F
+GLIBC_2.1.2
+ GLIBC_2.1.2 A
+ __vfork F
+ getaliasbyname_r F
+ getaliasent_r F
+ getgrent_r F
+ getgrgid_r F
+ getgrnam_r F
+ gethostbyaddr_r F
+ gethostbyname2_r F
+ gethostbyname_r F
+ gethostent_r F
+ getnetbyaddr_r F
+ getnetbyname_r F
+ getnetent_r F
+ getprotobyname_r F
+ getprotobynumber_r F
+ getprotoent_r F
+ getpwent_r F
+ getpwnam_r F
+ getpwuid_r F
+ getrpcbyname_r F
+ getrpcbynumber_r F
+ getrpcent_r F
+ getservbyname_r F
+ getservbyport_r F
+ getservent_r F
+ getspent_r F
+ getspnam_r F
+GLIBC_2.1.3
+ GLIBC_2.1.3 A
+ __cxa_atexit F
+ __cxa_finalize F
+ __sigsuspend F
+GLIBC_2.10
+ GLIBC_2.10 A
+ __cxa_at_quick_exit F
+ __posix_getopt F
+ accept4 F
+ endsgent F
+ fallocate F
+ fgetsgent F
+ fgetsgent_r F
+ getsgent F
+ getsgent_r F
+ getsgnam F
+ getsgnam_r F
+ malloc_info F
+ preadv F
+ preadv64 F
+ psiginfo F
+ putsgent F
+ pwritev F
+ pwritev64 F
+ quick_exit F
+ register_printf_modifier F
+ register_printf_specifier F
+ register_printf_type F
+ setsgent F
+ sgetsgent F
+ sgetsgent_r F
+GLIBC_2.11
+ GLIBC_2.11 A
+ __longjmp_chk F
+ execvpe F
+ mkostemps F
+ mkostemps64 F
+ mkstemps F
+ mkstemps64 F
+GLIBC_2.12
+ GLIBC_2.12 A
+ _sys_errlist D 0x21c
+ _sys_nerr D 0x4
+ ntp_gettimex F
+ recvmmsg F
+ sys_errlist D 0x21c
+ sys_nerr D 0x4
+GLIBC_2.13
+ GLIBC_2.13 A
+ fanotify_init F
+ fanotify_mark F
+ prlimit F
+ prlimit64 F
+GLIBC_2.14
+ GLIBC_2.14 A
+ clock_adjtime F
+ name_to_handle_at F
+ open_by_handle_at F
+ sendmmsg F
+ setns F
+ syncfs F
+GLIBC_2.15
+ GLIBC_2.15 A
+ __fdelt_chk F
+ __fdelt_warn F
+ fallocate64 F
+ posix_spawn F
+ posix_spawnp F
+ process_vm_readv F
+ process_vm_writev F
+ scandirat F
+ scandirat64 F
+GLIBC_2.16
+ GLIBC_2.16 A
+ __getauxval F
+ __poll_chk F
+ __ppoll_chk F
+ aligned_alloc F
+ c16rtomb F
+ c32rtomb F
+ getauxval F
+ mbrtoc16 F
+ mbrtoc32 F
+ timespec_get F
+GLIBC_2.17
+ GLIBC_2.17 A
+ clock_getcpuclockid F
+ clock_getres F
+ clock_gettime F
+ clock_nanosleep F
+ clock_settime F
+ secure_getenv F
+GLIBC_2.2
+ GLIBC_2.2 A
+ _IO_adjust_wcolumn F
+ _IO_fgetpos F
+ _IO_fgetpos64 F
+ _IO_free_wbackup_area F
+ _IO_fsetpos F
+ _IO_fsetpos64 F
+ _IO_init_wmarker F
+ _IO_iter_begin F
+ _IO_iter_end F
+ _IO_iter_file F
+ _IO_iter_next F
+ _IO_least_wmarker F
+ _IO_list_lock F
+ _IO_list_resetlock F
+ _IO_list_unlock F
+ _IO_seekwmark F
+ _IO_sputbackwc F
+ _IO_sungetwc F
+ _IO_switch_to_main_wget_area F
+ _IO_switch_to_wbackup_area F
+ _IO_switch_to_wget_mode F
+ _IO_unsave_wmarkers F
+ _IO_wdefault_doallocate F
+ _IO_wdefault_finish F
+ _IO_wdefault_pbackfail F
+ _IO_wdefault_uflow F
+ _IO_wdefault_xsgetn F
+ _IO_wdefault_xsputn F
+ _IO_wdo_write F
+ _IO_wdoallocbuf F
+ _IO_wfile_jumps D 0x54
+ _IO_wfile_overflow F
+ _IO_wfile_seekoff F
+ _IO_wfile_sync F
+ _IO_wfile_underflow F
+ _IO_wfile_xsputn F
+ _IO_wmarker_delta F
+ _IO_wsetb F
+ __assert F
+ __ctype32_tolower D 0x4
+ __ctype32_toupper D 0x4
+ __cyg_profile_func_enter F
+ __cyg_profile_func_exit F
+ __endmntent F
+ __fbufsize F
+ __flbf F
+ __fpending F
+ __fpurge F
+ __freadable F
+ __freading F
+ __fsetlocking F
+ __fwritable F
+ __fwriting F
+ __fxstat64 F
+ __getmntent_r F
+ __nl_langinfo_l F
+ __open64 F
+ __res_init F
+ __res_nclose F
+ __res_ninit F
+ __res_state F
+ __setmntent F
+ __statfs F
+ __strndup F
+ __sysconf F
+ __wctrans_l F
+ __woverflow F
+ __wuflow F
+ __wunderflow F
+ __xpg_sigpause F
+ _flushlbf F
+ _res_hconf D 0x30
+ bind_textdomain_codeset F
+ dcngettext F
+ dngettext F
+ fgetpos F
+ fgetpos64 F
+ fgetwc F
+ fgetwc_unlocked F
+ fgetws F
+ fgetws_unlocked F
+ fmemopen F
+ fopencookie F
+ fputwc F
+ fputwc_unlocked F
+ fputws F
+ fputws_unlocked F
+ fsetpos F
+ fsetpos64 F
+ fwide F
+ fwprintf F
+ fwscanf F
+ getdirentries64 F
+ getloadavg F
+ getwc F
+ getwc_unlocked F
+ getwchar F
+ getwchar_unlocked F
+ iruserok_af F
+ localeconv F
+ mcheck_check_all F
+ mcheck_pedantic F
+ memrchr F
+ mincore F
+ mkdtemp F
+ mkstemp64 F
+ moncontrol F
+ ngettext F
+ posix_fadvise F
+ posix_fadvise64 F
+ posix_fallocate F
+ posix_fallocate64 F
+ posix_madvise F
+ posix_memalign F
+ posix_spawn F
+ posix_spawn_file_actions_addclose F
+ posix_spawn_file_actions_adddup2 F
+ posix_spawn_file_actions_addopen F
+ posix_spawn_file_actions_destroy F
+ posix_spawn_file_actions_init F
+ posix_spawnattr_destroy F
+ posix_spawnattr_getflags F
+ posix_spawnattr_getpgroup F
+ posix_spawnattr_getschedparam F
+ posix_spawnattr_getschedpolicy F
+ posix_spawnattr_getsigdefault F
+ posix_spawnattr_getsigmask F
+ posix_spawnattr_init F
+ posix_spawnattr_setflags F
+ posix_spawnattr_setpgroup F
+ posix_spawnattr_setschedparam F
+ posix_spawnattr_setschedpolicy F
+ posix_spawnattr_setsigdefault F
+ posix_spawnattr_setsigmask F
+ posix_spawnp F
+ putwc F
+ putwc_unlocked F
+ putwchar F
+ putwchar_unlocked F
+ rcmd_af F
+ rexec_af F
+ rresvport_af F
+ ruserok_af F
+ semctl F
+ svc_getreq_common F
+ svc_getreq_poll F
+ svc_max_pollfd D 0x4
+ svc_pollfd D 0x4
+ swprintf F
+ swscanf F
+ ungetwc F
+ vfwprintf F
+ vfwscanf F
+ vswprintf F
+ vswscanf F
+ vwprintf F
+ vwscanf F
+ wcschrnul F
+ wcsftime F
+ wmempcpy F
+ wprintf F
+ wscanf F
+GLIBC_2.2.1
+ GLIBC_2.2.1 A
+ pivot_root F
+ posix_openpt F
+GLIBC_2.2.2
+ GLIBC_2.2.2 A
+ __nss_hostname_digits_dots F
+GLIBC_2.2.3
+ GLIBC_2.2.3 A
+ __rpc_thread_createerr F
+ __rpc_thread_svc_fdset F
+ __rpc_thread_svc_max_pollfd F
+ __rpc_thread_svc_pollfd F
+ fnmatch F
+ sprofil F
+GLIBC_2.2.4
+ GLIBC_2.2.4 A
+ dl_iterate_phdr F
+ getgrouplist F
+ sockatmark F
+GLIBC_2.2.6
+ GLIBC_2.2.6 A
+ __nanosleep F
+GLIBC_2.3
+ GLIBC_2.3 A
+ __ctype_b_loc F
+ __ctype_tolower_loc F
+ __ctype_toupper_loc F
+ __isctype F
+ __strftime_l F
+ __uselocale F
+ __wcsftime_l F
+ _sys_errlist D 0x1f8
+ _sys_nerr D 0x4
+ duplocale F
+ fgetxattr F
+ flistxattr F
+ freeifaddrs F
+ freelocale F
+ fremovexattr F
+ fsetxattr F
+ futimes F
+ getifaddrs F
+ getxattr F
+ isalnum_l F
+ isalpha_l F
+ isblank_l F
+ iscntrl_l F
+ isctype F
+ isdigit_l F
+ isgraph_l F
+ islower_l F
+ isprint_l F
+ ispunct_l F
+ isspace_l F
+ isupper_l F
+ iswalnum_l F
+ iswalpha_l F
+ iswblank_l F
+ iswcntrl_l F
+ iswctype_l F
+ iswdigit_l F
+ iswgraph_l F
+ iswlower_l F
+ iswprint_l F
+ iswpunct_l F
+ iswspace_l F
+ iswupper_l F
+ iswxdigit_l F
+ isxdigit_l F
+ lgetxattr F
+ listxattr F
+ llistxattr F
+ lremovexattr F
+ lsetxattr F
+ lutimes F
+ newlocale F
+ nl_langinfo_l F
+ readahead F
+ realpath F
+ removexattr F
+ sendfile64 F
+ setxattr F
+ strcasecmp_l F
+ strcoll_l F
+ strfmon_l F
+ strftime_l F
+ strncasecmp_l F
+ strtod_l F
+ strtof_l F
+ strtol_l F
+ strtold_l F
+ strtoll_l F
+ strtoul_l F
+ strtoull_l F
+ strxfrm_l F
+ sys_errlist D 0x1f8
+ sys_nerr D 0x4
+ tolower_l F
+ toupper_l F
+ towctrans_l F
+ towlower_l F
+ towupper_l F
+ uselocale F
+ wcscasecmp_l F
+ wcscoll_l F
+ wcsftime_l F
+ wcsncasecmp_l F
+ wcstod_l F
+ wcstof_l F
+ wcstol_l F
+ wcstold_l F
+ wcstoll_l F
+ wcstoul_l F
+ wcstoull_l F
+ wcsxfrm_l F
+ wctrans_l F
+ wctype_l F
+GLIBC_2.3.2
+ GLIBC_2.3.2 A
+ __register_atfork F
+ epoll_create F
+ epoll_ctl F
+ epoll_wait F
+ lchmod F
+ pthread_cond_broadcast F
+ pthread_cond_destroy F
+ pthread_cond_init F
+ pthread_cond_signal F
+ pthread_cond_timedwait F
+ pthread_cond_wait F
+ strptime_l F
+GLIBC_2.3.3
+ GLIBC_2.3.3 A
+ _sys_siglist D 0x104
+ gnu_dev_major F
+ gnu_dev_makedev F
+ gnu_dev_minor F
+ inet6_option_alloc F
+ inet6_option_append F
+ inet6_option_find F
+ inet6_option_init F
+ inet6_option_next F
+ inet6_option_space F
+ nftw F
+ nftw64 F
+ posix_fadvise64 F
+ posix_fallocate64 F
+ remap_file_pages F
+ sched_getaffinity F
+ sched_setaffinity F
+ semtimedop F
+ sys_sigabbrev D 0x104
+ sys_siglist D 0x104
+GLIBC_2.3.4
+ GLIBC_2.3.4 A
+ __chk_fail F
+ __fprintf_chk F
+ __gets_chk F
+ __memcpy_chk F
+ __memmove_chk F
+ __mempcpy_chk F
+ __memset_chk F
+ __printf_chk F
+ __snprintf_chk F
+ __sprintf_chk F
+ __stpcpy_chk F
+ __strcat_chk F
+ __strcpy_chk F
+ __strncat_chk F
+ __strncpy_chk F
+ __vfprintf_chk F
+ __vprintf_chk F
+ __vsnprintf_chk F
+ __vsprintf_chk F
+ __xpg_strerror_r F
+ getipv4sourcefilter F
+ getsourcefilter F
+ regexec F
+ sched_getaffinity F
+ sched_setaffinity F
+ setipv4sourcefilter F
+ setsourcefilter F
+ xdr_quad_t F
+ xdr_u_quad_t F
+GLIBC_2.4
+ GLIBC_2.4 A
+ __confstr_chk F
+ __fgets_chk F
+ __fgets_unlocked_chk F
+ __fgetws_chk F
+ __fgetws_unlocked_chk F
+ __fwprintf_chk F
+ __fxstatat F
+ __fxstatat64 F
+ __getcwd_chk F
+ __getdomainname_chk F
+ __getgroups_chk F
+ __gethostname_chk F
+ __getlogin_r_chk F
+ __getwd_chk F
+ __mbsnrtowcs_chk F
+ __mbsrtowcs_chk F
+ __mbstowcs_chk F
+ __pread64_chk F
+ __pread_chk F
+ __ptsname_r_chk F
+ __read_chk F
+ __readlink_chk F
+ __realpath_chk F
+ __recv_chk F
+ __recvfrom_chk F
+ __stack_chk_fail F
+ __stpncpy_chk F
+ __swprintf_chk F
+ __syslog_chk F
+ __ttyname_r_chk F
+ __vfwprintf_chk F
+ __vswprintf_chk F
+ __vsyslog_chk F
+ __vwprintf_chk F
+ __wcpcpy_chk F
+ __wcpncpy_chk F
+ __wcrtomb_chk F
+ __wcscat_chk F
+ __wcscpy_chk F
+ __wcsncat_chk F
+ __wcsncpy_chk F
+ __wcsnrtombs_chk F
+ __wcsrtombs_chk F
+ __wcstombs_chk F
+ __wctomb_chk F
+ __wmemcpy_chk F
+ __wmemmove_chk F
+ __wmempcpy_chk F
+ __wmemset_chk F
+ __wprintf_chk F
+ __xmknodat F
+ _sys_errlist D 0x210
+ _sys_nerr D 0x4
+ eaccess F
+ faccessat F
+ fchmodat F
+ fchownat F
+ fdopendir F
+ futimesat F
+ inotify_add_watch F
+ inotify_init F
+ inotify_rm_watch F
+ linkat F
+ mkdirat F
+ mkfifoat F
+ open_wmemstream F
+ openat F
+ openat64 F
+ ppoll F
+ readlinkat F
+ renameat F
+ symlinkat F
+ sys_errlist D 0x210
+ sys_nerr D 0x4
+ unlinkat F
+ unshare F
+GLIBC_2.5
+ GLIBC_2.5 A
+ __readlinkat_chk F
+ inet6_opt_append F
+ inet6_opt_find F
+ inet6_opt_finish F
+ inet6_opt_get_val F
+ inet6_opt_init F
+ inet6_opt_next F
+ inet6_opt_set_val F
+ inet6_rth_add F
+ inet6_rth_getaddr F
+ inet6_rth_init F
+ inet6_rth_reverse F
+ inet6_rth_segments F
+ inet6_rth_space F
+ splice F
+ tee F
+ vmsplice F
+GLIBC_2.6
+ GLIBC_2.6 A
+ __sched_cpucount F
+ epoll_pwait F
+ futimens F
+ sched_getcpu F
+ strerror_l F
+ sync_file_range F
+ utimensat F
+GLIBC_2.7
+ GLIBC_2.7 A
+ __fread_chk F
+ __fread_unlocked_chk F
+ __isoc99_fscanf F
+ __isoc99_fwscanf F
+ __isoc99_scanf F
+ __isoc99_sscanf F
+ __isoc99_swscanf F
+ __isoc99_vfscanf F
+ __isoc99_vfwscanf F
+ __isoc99_vscanf F
+ __isoc99_vsscanf F
+ __isoc99_vswscanf F
+ __isoc99_vwscanf F
+ __isoc99_wscanf F
+ __open64_2 F
+ __open_2 F
+ __openat64_2 F
+ __openat_2 F
+ __sched_cpualloc F
+ __sched_cpufree F
+ eventfd F
+ eventfd_read F
+ eventfd_write F
+ mkostemp F
+ mkostemp64 F
+ signalfd F
+GLIBC_2.8
+ GLIBC_2.8 A
+ __asprintf_chk F
+ __dprintf_chk F
+ __obstack_printf_chk F
+ __obstack_vprintf_chk F
+ __vasprintf_chk F
+ __vdprintf_chk F
+ qsort_r F
+ timerfd_create F
+ timerfd_gettime F
+ timerfd_settime F
+GLIBC_2.9
+ GLIBC_2.9 A
+ dup3 F
+ epoll_create1 F
+ inotify_init1 F
+ pipe2 F
--- /dev/null
+++ eglibc-2.18/ports/sysdeps/unix/sysv/linux/or1k/nptl/libcrypt.abilist
@@ -0,0 +1,9 @@
+GLIBC_2.0
+ GLIBC_2.0 A
+ crypt F
+ crypt_r F
+ encrypt F
+ encrypt_r F
+ fcrypt F
+ setkey F
+ setkey_r F
--- /dev/null
+++ eglibc-2.18/ports/sysdeps/unix/sysv/linux/or1k/nptl/localplt.data
@@ -0,0 +1,7 @@
+libc.so: _Unwind_Find_FDE
+libc.so: calloc
+libc.so: free
+libc.so: malloc
+libc.so: memalign
+libc.so: realloc
+libm.so: matherr
--- /dev/null
+++ eglibc-2.18/ports/sysdeps/unix/sysv/linux/or1k/nptl/lowlevellock.h
@@ -0,0 +1,280 @@
+/* Copyright (C) 2011 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Chris Metcalf <cmetcalf@tilera.com>, 2011.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _LOWLEVELLOCK_H
+#define _LOWLEVELLOCK_H	1
+
+#include <time.h>
+#include <sys/param.h>
+#include <bits/pthreadtypes.h>
+#include <atomic.h>
+#include <sysdep.h>
+#include <kernel-features.h>
+
+
+#define FUTEX_WAIT		0
+#define FUTEX_WAKE		1
+#define FUTEX_REQUEUE		3
+#define FUTEX_CMP_REQUEUE	4
+#define FUTEX_WAKE_OP		5
+#define FUTEX_OP_CLEAR_WAKE_IF_GT_ONE	((4 << 24) | 1)
+#define FUTEX_LOCK_PI		6
+#define FUTEX_UNLOCK_PI		7
+#define FUTEX_TRYLOCK_PI	8
+#define FUTEX_WAIT_BITSET	9
+#define FUTEX_WAKE_BITSET	10
+#define FUTEX_PRIVATE_FLAG	128
+#define FUTEX_CLOCK_REALTIME	256
+
+#define FUTEX_BITSET_MATCH_ANY	0xffffffff
+
+/* Values for 'private' parameter of locking macros.  Yes, the
+   definition seems to be backwards.  But it is not.  The bit will be
+   reversed before passing to the system call.  */
+#define LLL_PRIVATE	0
+#define LLL_SHARED	FUTEX_PRIVATE_FLAG
+
+
+#if !defined NOT_IN_libc || defined IS_IN_rtld
+/* In libc.so or ld.so all futexes are private.  */
+# ifdef __ASSUME_PRIVATE_FUTEX
+#  define __lll_private_flag(fl, private) \
+  ((fl) | FUTEX_PRIVATE_FLAG)
+# else
+#  define __lll_private_flag(fl, private) \
+  ((fl) | THREAD_GETMEM (THREAD_SELF, header.private_futex))
+# endif
+#else
+# ifdef __ASSUME_PRIVATE_FUTEX
+#  define __lll_private_flag(fl, private) \
+  (((fl) | FUTEX_PRIVATE_FLAG) ^ (private))
+# else
+#  define __lll_private_flag(fl, private) \
+  (__builtin_constant_p (private)					      \
+   ? ((private) == 0							      \
+      ? ((fl) | THREAD_GETMEM (THREAD_SELF, header.private_futex))	      \
+      : (fl))								      \
+   : ((fl) | (((private) ^ FUTEX_PRIVATE_FLAG)				      \
+	      & THREAD_GETMEM (THREAD_SELF, header.private_futex))))
+# endif
+#endif
+
+
+#define lll_futex_wait(futexp, val, private) \
+  lll_futex_timed_wait (futexp, val, NULL, private)
+
+#define lll_futex_timed_wait(futexp, val, timespec, private) \
+  ({									      \
+    INTERNAL_SYSCALL_DECL (__err);					      \
+    INTERNAL_SYSCALL (futex, __err, 4, (futexp),			      \
+			      __lll_private_flag (FUTEX_WAIT, private),	      \
+			      (val), (timespec));			      \
+  })
+
+#define lll_futex_wake(futexp, nr, private) \
+  ({									      \
+    INTERNAL_SYSCALL_DECL (__err);					      \
+    INTERNAL_SYSCALL (futex, __err, 4, (futexp),			      \
+			      __lll_private_flag (FUTEX_WAKE, private),	      \
+			      (nr), 0);					      \
+  })
+
+#define lll_robust_dead(futexv, private) \
+  do									      \
+    {									      \
+      int *__futexp = &(futexv);					      \
+      atomic_or (__futexp, FUTEX_OWNER_DIED);				      \
+      lll_futex_wake (__futexp, 1, private);				      \
+    }									      \
+  while (0)
+
+/* Returns non-zero if error happened, zero if success.  */
+#define lll_futex_requeue(futexp, nr_wake, nr_move, mutex, val, private) \
+  ({									      \
+    INTERNAL_SYSCALL_DECL (__err);					      \
+    long int __ret;							      \
+    __ret = INTERNAL_SYSCALL (futex, __err, 6, (futexp),		      \
+			      __lll_private_flag (FUTEX_CMP_REQUEUE, private),\
+			      (nr_wake), (nr_move), (mutex), (val));	      \
+    INTERNAL_SYSCALL_ERROR_P (__ret, __err);				      \
+  })
+
+/* Returns non-zero if error happened, zero if success.  */
+#define lll_futex_wake_unlock(futexp, nr_wake, nr_wake2, futexp2, private) \
+  ({									      \
+    INTERNAL_SYSCALL_DECL (__err);					      \
+    long int __ret;							      \
+    __ret = INTERNAL_SYSCALL (futex, __err, 6, (futexp),		      \
+			      __lll_private_flag (FUTEX_WAKE_OP, private),    \
+			      (nr_wake), (nr_wake2), (futexp2),		      \
+			      FUTEX_OP_CLEAR_WAKE_IF_GT_ONE);		      \
+    INTERNAL_SYSCALL_ERROR_P (__ret, __err);				      \
+  })
+
+
+
+
+static inline int __attribute__ ((always_inline))
+__lll_trylock (int *futex)
+{
+  return atomic_compare_and_exchange_val_acq (futex, 1, 0) != 0;
+}
+#define lll_trylock(lock)	__lll_trylock (&(lock))
+
+
+static inline int __attribute__ ((always_inline))
+__lll_cond_trylock (int *futex)
+{
+  return atomic_compare_and_exchange_val_acq (futex, 2, 0) != 0;
+}
+#define lll_cond_trylock(lock)	__lll_cond_trylock (&(lock))
+
+
+static inline int __attribute__ ((always_inline))
+__lll_robust_trylock (int *futex, int id)
+{
+  return atomic_compare_and_exchange_val_acq (futex, id, 0) != 0;
+}
+#define lll_robust_trylock(lock, id) \
+  __lll_robust_trylock (&(lock), id)
+
+extern void __lll_lock_wait_private (int *futex) attribute_hidden;
+extern void __lll_lock_wait (int *futex, int private) attribute_hidden;
+extern int __lll_robust_lock_wait (int *futex, int private) attribute_hidden;
+
+static inline void __attribute__ ((always_inline))
+__lll_lock (int *futex, int private)
+{
+  if (atomic_compare_and_exchange_bool_acq (futex, 1, 0) != 0)
+    {
+      if (__builtin_constant_p (private) && private == LLL_PRIVATE)
+	__lll_lock_wait_private (futex);
+      else
+	__lll_lock_wait (futex, private);
+    }
+}
+#define lll_lock(futex, private) __lll_lock (&(futex), private)
+
+
+static inline int __attribute__ ((always_inline))
+__lll_robust_lock (int *futex, int id, int private)
+{
+  int result = 0;
+  if (atomic_compare_and_exchange_bool_acq (futex, id, 0) != 0)
+    result = __lll_robust_lock_wait (futex, private);
+  return result;
+}
+#define lll_robust_lock(futex, id, private) \
+  __lll_robust_lock (&(futex), id, private)
+
+
+static inline void __attribute__ ((always_inline))
+__lll_cond_lock (int *futex, int private)
+{
+  if (atomic_compare_and_exchange_bool_acq (futex, 2, 0) != 0)
+    __lll_lock_wait (futex, private);
+}
+#define lll_cond_lock(futex, private) __lll_cond_lock (&(futex), private)
+
+
+#define lll_robust_cond_lock(futex, id, private) \
+  __lll_robust_lock (&(futex), (id) | FUTEX_WAITERS, private)
+
+
+extern int __lll_timedlock_wait (int *futex, const struct timespec *,
+				 int private) attribute_hidden;
+extern int __lll_robust_timedlock_wait (int *futex, const struct timespec *,
+					int private) attribute_hidden;
+
+static inline int __attribute__ ((always_inline))
+__lll_timedlock (int *futex, const struct timespec *abstime, int private)
+{
+  int result = 0;
+  if (atomic_compare_and_exchange_bool_acq (futex, 1, 0) != 0)
+    result = __lll_timedlock_wait (futex, abstime, private);
+  return result;
+}
+#define lll_timedlock(futex, abstime, private) \
+  __lll_timedlock (&(futex), abstime, private)
+
+
+static inline int __attribute__ ((always_inline))
+__lll_robust_timedlock (int *futex, const struct timespec *abstime,
+			int id, int private)
+{
+  int result = 0;
+  if (atomic_compare_and_exchange_bool_acq (futex, id, 0) != 0)
+    result = __lll_robust_timedlock_wait (futex, abstime, private);
+  return result;
+}
+#define lll_robust_timedlock(futex, abstime, id, private) \
+  __lll_robust_timedlock (&(futex), abstime, id, private)
+
+
+#define __lll_unlock(futex, private) \
+  (void)							\
+    ({ int *__futex = (futex);					\
+       int __oldval = atomic_exchange_rel (__futex, 0);		\
+       if (__builtin_expect (__oldval > 1, 0))			\
+	 lll_futex_wake (__futex, 1, private);			\
+    })
+#define lll_unlock(futex, private) __lll_unlock(&(futex), private)
+
+
+#define __lll_robust_unlock(futex, private) \
+  (void)							\
+    ({ int *__futex = (futex);					\
+       int __oldval = atomic_exchange_rel (__futex, 0);		\
+       if (__builtin_expect (__oldval & FUTEX_WAITERS, 0))	\
+	 lll_futex_wake (__futex, 1, private);			\
+    })
+#define lll_robust_unlock(futex, private) \
+  __lll_robust_unlock(&(futex), private)
+
+
+#define lll_islocked(futex) \
+  (futex != 0)
+
+/* Initializers for lock.  */
+#define LLL_LOCK_INITIALIZER		(0)
+#define LLL_LOCK_INITIALIZER_LOCKED	(1)
+
+
+/* The kernel notifies a process which uses CLONE_CHILD_CLEARTID via futex
+   wakeup when the clone terminates.  The memory location contains the
+   thread ID while the clone is running and is reset to zero
+   afterwards.	*/
+#define lll_wait_tid(tid) \
+  do {							\
+    __typeof (tid) __tid;				\
+    while ((__tid = (tid)) != 0)			\
+      lll_futex_wait (&(tid), __tid, LLL_SHARED);	\
+  } while (0)
+
+extern int __lll_timedwait_tid (int *, const struct timespec *)
+  attribute_hidden;
+
+#define lll_timedwait_tid(tid, abstime) \
+  ({							\
+    int __res = 0;					\
+    if ((tid) != 0)					\
+      __res = __lll_timedwait_tid (&(tid), (abstime));	\
+    __res;						\
+  })
+
+#endif /* lowlevellock.h */
--- /dev/null
+++ eglibc-2.18/ports/sysdeps/unix/sysv/linux/or1k/nptl/libdl.abilist
@@ -0,0 +1,18 @@
+GLIBC_2.0
+ GLIBC_2.0 A
+ dladdr F
+ dlclose F
+ dlerror F
+ dlopen F
+ dlsym F
+GLIBC_2.1
+ GLIBC_2.1 A
+ dlopen F
+ dlvsym F
+GLIBC_2.3.3
+ GLIBC_2.3.3 A
+ dladdr1 F
+ dlinfo F
+GLIBC_2.3.4
+ GLIBC_2.3.4 A
+ dlmopen F
--- /dev/null
+++ eglibc-2.18/ports/sysdeps/unix/sysv/linux/or1k/nptl/libnsl.abilist
@@ -0,0 +1,127 @@
+GLIBC_2.0
+ GLIBC_2.0 A
+ __yp_check F
+ xdr_domainname F
+ xdr_keydat F
+ xdr_mapname F
+ xdr_peername F
+ xdr_valdat F
+ xdr_yp_buf F
+ xdr_ypbind_binding F
+ xdr_ypbind_resp F
+ xdr_ypbind_resptype F
+ xdr_ypbind_setdom F
+ xdr_ypdelete_args F
+ xdr_ypmap_parms F
+ xdr_ypmaplist F
+ xdr_yppush_status F
+ xdr_yppushresp_xfr F
+ xdr_ypreq_key F
+ xdr_ypreq_nokey F
+ xdr_ypreq_xfr F
+ xdr_ypresp_all F
+ xdr_ypresp_key_val F
+ xdr_ypresp_maplist F
+ xdr_ypresp_master F
+ xdr_ypresp_order F
+ xdr_ypresp_val F
+ xdr_ypresp_xfr F
+ xdr_ypstat F
+ xdr_ypupdate_args F
+ xdr_ypxfrstat F
+ yp_all F
+ yp_bind F
+ yp_first F
+ yp_get_default_domain F
+ yp_maplist F
+ yp_master F
+ yp_match F
+ yp_next F
+ yp_order F
+ yp_unbind F
+ yp_update F
+ ypbinderr_string F
+ yperr_string F
+ ypprot_err F
+GLIBC_2.1
+ GLIBC_2.1 A
+ __free_fdresult F
+ __nis_default_access F
+ __nis_default_group F
+ __nis_default_owner F
+ __nis_default_ttl F
+ __nis_finddirectory F
+ __nis_hash F
+ __nisbind_connect F
+ __nisbind_create F
+ __nisbind_destroy F
+ __nisbind_next F
+ nis_add F
+ nis_add_entry F
+ nis_addmember F
+ nis_checkpoint F
+ nis_clone_directory F
+ nis_clone_object F
+ nis_clone_result F
+ nis_creategroup F
+ nis_destroy_object F
+ nis_destroygroup F
+ nis_dir_cmp F
+ nis_domain_of F
+ nis_domain_of_r F
+ nis_first_entry F
+ nis_free_directory F
+ nis_free_object F
+ nis_free_request F
+ nis_freenames F
+ nis_freeresult F
+ nis_freeservlist F
+ nis_freetags F
+ nis_getnames F
+ nis_getservlist F
+ nis_ismember F
+ nis_leaf_of F
+ nis_leaf_of_r F
+ nis_lerror F
+ nis_list F
+ nis_local_directory F
+ nis_local_group F
+ nis_local_host F
+ nis_local_principal F
+ nis_lookup F
+ nis_mkdir F
+ nis_modify F
+ nis_modify_entry F
+ nis_name_of F
+ nis_name_of_r F
+ nis_next_entry F
+ nis_perror F
+ nis_ping F
+ nis_print_directory F
+ nis_print_entry F
+ nis_print_group F
+ nis_print_group_entry F
+ nis_print_link F
+ nis_print_object F
+ nis_print_result F
+ nis_print_rights F
+ nis_print_table F
+ nis_read_obj F
+ nis_remove F
+ nis_remove_entry F
+ nis_removemember F
+ nis_rmdir F
+ nis_servstate F
+ nis_sperrno F
+ nis_sperror F
+ nis_sperror_r F
+ nis_stats F
+ nis_verifygroup F
+ nis_write_obj F
+ readColdStartFile F
+ writeColdStartFile F
+ xdr_cback_data F
+ xdr_obj_p F
+GLIBC_2.2
+ GLIBC_2.2 A
+ xdr_ypall F
--- /dev/null
+++ eglibc-2.18/ports/sysdeps/unix/sysv/linux/or1k/nptl/fork.c
@@ -0,0 +1,30 @@
+/* Copyright (C) 2005 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Phil Blundell <pb@nexus.co.uk>, 2005
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <sched.h>
+#include <signal.h>
+#include <sysdep.h>
+#include <tls.h>
+
+
+#define ARCH_FORK()							\
+  INLINE_SYSCALL (clone, 5,						\
+		  CLONE_CHILD_SETTID | CLONE_CHILD_CLEARTID | SIGCHLD,	\
+		  NULL, NULL, &THREAD_SELF->tid, NULL)
+
+#include <nptl/sysdeps/unix/sysv/linux/fork.c>
--- /dev/null
+++ eglibc-2.18/ports/sysdeps/unix/sysv/linux/or1k/nptl/libanl.abilist
@@ -0,0 +1,6 @@
+GLIBC_2.2.3
+ GLIBC_2.2.3 A
+ gai_cancel F
+ gai_error F
+ gai_suspend F
+ getaddrinfo_a F
--- /dev/null
+++ eglibc-2.18/ports/sysdeps/unix/sysv/linux/or1k/nptl/librt.abilist
@@ -0,0 +1,52 @@
+GLIBC_2.1
+ GLIBC_2.1 A
+ aio_cancel F
+ aio_cancel64 F
+ aio_error F
+ aio_error64 F
+ aio_fsync F
+ aio_fsync64 F
+ aio_init F
+ aio_read F
+ aio_read64 F
+ aio_return F
+ aio_return64 F
+ aio_suspend F
+ aio_suspend64 F
+ aio_write F
+ aio_write64 F
+ lio_listio F
+ lio_listio64 F
+GLIBC_2.2
+ GLIBC_2.2 A
+ clock_getcpuclockid F
+ clock_getres F
+ clock_gettime F
+ clock_nanosleep F
+ clock_settime F
+ shm_open F
+ shm_unlink F
+ timer_create F
+ timer_delete F
+ timer_getoverrun F
+ timer_gettime F
+ timer_settime F
+GLIBC_2.3.4
+ GLIBC_2.3.4 A
+ mq_close F
+ mq_getattr F
+ mq_notify F
+ mq_open F
+ mq_receive F
+ mq_send F
+ mq_setattr F
+ mq_timedreceive F
+ mq_timedsend F
+ mq_unlink F
+GLIBC_2.4
+ GLIBC_2.4 A
+ lio_listio F
+ lio_listio64 F
+GLIBC_2.7
+ GLIBC_2.7 A
+ __mq_open_2 F
--- /dev/null
+++ eglibc-2.18/ports/sysdeps/unix/sysv/linux/or1k/nptl/libutil.abilist
@@ -0,0 +1,8 @@
+GLIBC_2.0
+ GLIBC_2.0 A
+ forkpty F
+ login F
+ login_tty F
+ logout F
+ logwtmp F
+ openpty F
--- /dev/null
+++ eglibc-2.18/ports/sysdeps/unix/sysv/linux/or1k/nptl/bits/semaphore.h
@@ -0,0 +1,34 @@
+/* Copyright (C) 2002, 2005, 2007 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _SEMAPHORE_H
+# error "Never use <bits/semaphore.h> directly; include <semaphore.h> instead."
+#endif
+
+
+#define __SIZEOF_SEM_T	16
+
+
+/* Value returned if `sem_open' failed.  */
+#define SEM_FAILED      ((sem_t *) 0)
+
+
+typedef union
+{
+  char __size[__SIZEOF_SEM_T];
+  long int __align;
+} sem_t;
--- /dev/null
+++ eglibc-2.18/ports/sysdeps/or1k/setjmp.S
@@ -0,0 +1,80 @@
+/* setjmp for or1k
+
+   Based on:
+   setjmp for PowerPC.
+   Copyright (C) 1995, 1996, 1997, 1999, 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <sysdep.h>
+#define _ASM
+#define _SETJMP_H
+#include <bits/setjmp.h>
+
+ENTRY (_setjmp)
+	l.addi	r4,r0,0			/* Set second argument to 0.  */
+	l.j	.Local__sigsetjmp
+	l.nop
+END (_setjmp)
+libc_hidden_def (_setjmp)
+
+ENTRY (setjmp)
+	l.addi	r4,r0,1			/* Set second argument to 1.  */
+	l.j	.Local__sigsetjmp
+	l.nop
+END (setjmp)
+
+ENTRY (__sigsetjmp)
+.Local__sigsetjmp:
+#	l.mfspr	r11,r0,SPR_SR
+#	l.sw    (JB_SR*4)(r3),r11
+	l.sw    ((JB_GPRS+0)*4)(r3),r1
+	l.sw    ((JB_GPRS+1)*4)(r3),r2
+/*	l.sw    ((JB_GPRS+2)*4)(r3),r3*/
+	l.sw    ((JB_GPRS+3)*4)(r3),r4
+	l.sw    ((JB_GPRS+4)*4)(r3),r5
+	l.sw    ((JB_GPRS+5)*4)(r3),r6
+	l.sw    ((JB_GPRS+6)*4)(r3),r7
+	l.sw    ((JB_GPRS+7)*4)(r3),r8
+	l.sw    ((JB_GPRS+8)*4)(r3),r9
+	l.sw    ((JB_GPRS+9)*4)(r3),r10
+	l.sw    ((JB_GPRS+10)*4)(r3),r11
+	l.sw    ((JB_GPRS+11)*4)(r3),r12
+	l.sw    ((JB_GPRS+12)*4)(r3),r13
+	l.sw    ((JB_GPRS+13)*4)(r3),r14
+	l.sw    ((JB_GPRS+14)*4)(r3),r15
+	l.sw    ((JB_GPRS+15)*4)(r3),r16
+	l.sw    ((JB_GPRS+16)*4)(r3),r17
+	l.sw    ((JB_GPRS+17)*4)(r3),r18
+	l.sw    ((JB_GPRS+18)*4)(r3),r19
+	l.sw    ((JB_GPRS+19)*4)(r3),r20
+	l.sw    ((JB_GPRS+20)*4)(r3),r21
+	l.sw    ((JB_GPRS+21)*4)(r3),r22
+	l.sw    ((JB_GPRS+22)*4)(r3),r23
+	l.sw    ((JB_GPRS+23)*4)(r3),r24
+	l.sw    ((JB_GPRS+24)*4)(r3),r25
+	l.sw    ((JB_GPRS+25)*4)(r3),r26
+	l.sw    ((JB_GPRS+26)*4)(r3),r27
+	l.sw    ((JB_GPRS+27)*4)(r3),r28
+	l.sw    ((JB_GPRS+28)*4)(r3),r29
+	l.sw    ((JB_GPRS+29)*4)(r3),r30
+	l.sw    ((JB_GPRS+30)*4)(r3),r31
+	l.j	__sigjmp_save
+	l.nop
+END (__sigsetjmp)
+hidden_def (__sigsetjmp)
+
--- /dev/null
+++ eglibc-2.18/ports/sysdeps/or1k/sysdep.h
@@ -0,0 +1,88 @@
+/* Assembler macros for OR1k.
+   Copyright (C) 1997, 1998, 2003, 2009, 2010, 2012
+   Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <sysdeps/generic/sysdep.h>
+#include <features.h>
+
+/* TODO: clean up this file */
+#ifdef	__ASSEMBLER__
+
+/* Syntactic details of assembler.  */
+
+#define ALIGNARG(log2) log2
+#define ASM_SIZE_DIRECTIVE(name) .size name,.-name
+
+#define PLTJMP(_x)	_x##(PLT)
+
+#define RETINSTR(cond, reg)	\
+	mov##cond	pc, reg
+#define DO_RET(_reg)		\
+	.jr _reg
+
+/* Define an entry point visible from C.  */
+#define	ENTRY(name)							      \
+  .globl C_SYMBOL_NAME(name);						      \
+  .type C_SYMBOL_NAME(name),%function;					      \
+  .align ALIGNARG(4);							      \
+  C_LABEL(name)								      \
+  .cfi_sections .debug_frame;						      \
+  cfi_startproc;							      \
+  CALL_MCOUNT
+
+#undef	END
+#define END(name)							      \
+  cfi_endproc;								      \
+  ASM_SIZE_DIRECTIVE(name)
+
+/* If compiled for profiling, call `mcount' at the start of each function.  */
+#ifdef	PROF
+/* Call __gnu_mcount_nc if GCC >= 4.4.  */
+#if __GNUC_PREREQ(4,4)
+#define CALL_MCOUNT \
+  str	lr,[sp, #-4]!; \
+  cfi_adjust_cfa_offset (4); \
+  cfi_rel_offset (lr, 0); \
+  bl PLTJMP(mcount); \
+  cfi_adjust_cfa_offset (-4); \
+  cfi_restore (lr)
+#else /* else call _mcount */
+#define CALL_MCOUNT \
+  str	lr,[sp, #-4]!; \
+  cfi_adjust_cfa_offset (4); \
+  cfi_rel_offset (lr, 0); \
+  bl PLTJMP(mcount); \
+  ldr lr, [sp], #4; \
+  cfi_adjust_cfa_offset (-4); \
+  cfi_restore (lr)
+#endif
+#else
+#define CALL_MCOUNT		/* Do nothing.  */
+#endif
+
+/* Since C identifiers are not normally prefixed with an underscore
+   on this system, the asm identifier `syscall_error' intrudes on the
+   C name space.  Make sure we use an innocuous name.  */
+#define	syscall_error	__syscall_error
+#if __GNUC_PREREQ(4,4)
+#define mcount		__gnu_mcount_nc
+#else
+#define mcount		_mcount
+#endif
+
+#endif	/* __ASSEMBLER__ */
--- /dev/null
+++ eglibc-2.18/ports/sysdeps/or1k/Makefile
@@ -0,0 +1,7 @@
+ASFLAGS-.os += -fPIC
+
+ifeq ($(subdir),elf)
+# Extra shared linker files to link only into dl-allobjs.so.
+sysdep-rtld-routines += dl-start
+endif
+
--- /dev/null
+++ eglibc-2.18/ports/sysdeps/or1k/stackinfo.h
@@ -0,0 +1,33 @@
+/* Copyright (C) 2013 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* This file contains a bit of information about the stack allocation
+   of the processor.  */
+
+#ifndef _STACKINFO_H
+#define _STACKINFO_H	1
+
+#include <elf.h>
+
+/* On or1k the stack grows down.  */
+#define _STACK_GROWS_DOWN	1
+
+/* Default to an executable stack.  PF_X can be overridden if PT_GNU_STACK is
+ * present, but it is presumed absent.  */
+#define DEFAULT_STACK_PERMS (PF_R|PF_W|PF_X)
+
+#endif /* stackinfo.h */
--- /dev/null
+++ eglibc-2.18/ports/sysdeps/or1k/dl-tls.h
@@ -0,0 +1,30 @@
+/* Copyright (C) 2005-2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* Type used for the representation of TLS information in the GOT.  */
+typedef struct
+{
+  unsigned long int ti_module;
+  unsigned long int ti_offset;
+} tls_index;
+
+
+extern void *__tls_get_addr (tls_index *ti);
+
+/* Value used for dtv entries for which the allocation is delayed.  */
+#define TLS_DTV_UNALLOCATED ((void *) -1l)
--- /dev/null
+++ eglibc-2.18/ports/sysdeps/or1k/crtn.S
@@ -0,0 +1,35 @@
+# End .init and .fini sections.
+# Copyright (C) 2010 Embecosm Limited
+# 
+# This file is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3, or (at your option)
+# any later version.
+# 
+# GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+# WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# for more details.
+# 
+# Under Section 7 of GPL version 3, you are granted additional
+# permissions described in the GCC Runtime Library Exception, version
+# 3.1, as published by the Free Software Foundation.
+#
+# You should have received a copy of the GNU General Public License and
+# a copy of the GCC Runtime Library Exception along with this program;
+# see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+# <http://www.gnu.org/licenses/>.
+
+  .section .init
+__init:
+  l.lwz r9,0(r1)
+  l.lwz r16,4(r1)
+  l.jr  r9
+  l.addi  r1,r1,8
+
+  .section .fini
+__fini:
+  l.lwz r9,0(r1)
+  l.jr  r9
+  l.addi  r1,r1,4
+
--- /dev/null
+++ eglibc-2.18/ports/sysdeps/or1k/preconfigure
@@ -0,0 +1,36 @@
+#
+# This is free and unencumbered software released into the public domain.
+# 
+# Anyone is free to copy, modify, publish, use, compile, sell, or
+# distribute this software, either in source code form or as a compiled
+# binary, for any purpose, commercial or non-commercial, and by any
+# means.
+# 
+# In jurisdictions that recognize copyright laws, the author or authors
+# of this software dedicate any and all copyright interest in the
+# software to the public domain. We make this dedication for the benefit
+# of the public at large and to the detriment of our heirs and
+# successors. We intend this dedication to be an overt act of
+# relinquishment in perpetuity of all present and future rights to this
+# software under copyright law.
+# 
+# THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+# EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+# MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+# IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+# OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+# ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+# OTHER DEALINGS IN THE SOFTWARE.
+#
+
+case "$machine" in
+or1k*)
+  base_machine=or1k
+  machine=or1k
+
+  # Needed for relro detection
+  libc_commonpagesize=0x2000
+  libc_relro_required=yes
+  ;;
+esac
+
--- /dev/null
+++ eglibc-2.18/ports/sysdeps/or1k/dl-trampoline.S
@@ -0,0 +1,81 @@
+/*
+   Based on the or1k version from uClibc.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* This code is used to call _dl_linux_resolver (dl-runtime.c).
+
+   We assume that R11 contain relocation offset and R12 contains
+   link_map (_DYNAMIC). This must be consistent with the JUMP_SLOT
+   layout generated by binutils. */
+
+        .section .text
+        .align 4
+
+.global _dl_runtime_resolve
+.type  _dl_runtime_resolve, @function
+
+_dl_runtime_resolve:
+        .cfi_startproc
+        l.sw    -4(r1), r9
+        l.sw    -8(r1), r1
+
+        /* save function arguments */
+        l.sw    -12(r1), r3
+        l.sw    -16(r1), r4
+        l.sw    -20(r1), r5
+        l.sw    -24(r1), r6
+        l.sw    -28(r1), r7
+        l.sw    -32(r1), r8
+
+        .cfi_offset 9, -4
+        .cfi_offset 1, -8
+        .cfi_offset 3, -12
+        .cfi_offset 4, -16
+        .cfi_offset 5, -20
+        .cfi_offset 6, -24
+        .cfi_offset 7, -28
+        .cfi_offset 8, -32
+
+        l.addi  r1,r1, -32
+        .cfi_def_cfa_offset 32
+
+        l.ori   r3, r12, 0
+        l.ori   r4, r11, 0
+
+        l.jal   _dl_fixup
+        l.nop
+
+        /* restore function arguments */
+        l.addi  r1,r1, 32
+        l.lwz   r8, -32(r1)
+        l.lwz   r7, -28(r1)
+        l.lwz   r6, -24(r1)
+        l.lwz   r5, -20(r1)
+        l.lwz   r4, -16(r1)
+        l.lwz   r3, -12(r1)
+
+        /* restore return address */
+        l.lwz   r9, -4(r1)
+
+        l.jr    r11
+        l.nop
+
+        .cfi_endproc
+        .size _dl_runtime_resolve, . - _dl_runtime_resolve
+
+/* TODO: _dl_runtime_profile */
+
--- /dev/null
+++ eglibc-2.18/ports/sysdeps/or1k/memusage.h
@@ -0,0 +1,20 @@
+/* Copyright (C) 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#define GETSP() ({ register uintptr_t stack_ptr asm ("r1"); stack_ptr; })
+
+#include <sysdeps/generic/memusage.h>
--- /dev/null
+++ eglibc-2.18/ports/sysdeps/or1k/bsd-setjmp.S
@@ -0,0 +1 @@
+/* setjmp is in setjmp.S  */
--- /dev/null
+++ eglibc-2.18/ports/sysdeps/or1k/ldsodefs.h
@@ -0,0 +1,40 @@
+/* Run-time dynamic linker data structures for loaded ELF shared objects.
+   Copyright (C) 1995-2012 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef	_SH_LDSODEFS_H
+#define	_SH_LDSODEFS_H	1
+
+#include <elf.h>
+
+struct La_or1k_regs;
+struct La_or1k_retval;
+
+#define ARCH_PLTENTER_MEMBERS						\
+    uintptr_t (*or1k_gnu_pltenter) (Elf32_Sym *, unsigned int, uintptr_t *, \
+				  uintptr_t *, struct La_or1k_regs *, \
+				  unsigned int *, const char *name,	\
+				  long int *framesizep)
+
+#define ARCH_PLTEXIT_MEMBERS						\
+    unsigned int (*or1k_gnu_pltexit) (Elf32_Sym *, unsigned int, uintptr_t *, \
+				    uintptr_t *, const struct La_or1k_regs *, \
+				    struct La_or1k_retval *, const char *)
+
+#include_next <ldsodefs.h>
+
+#endif
--- /dev/null
+++ eglibc-2.18/ports/sysdeps/or1k/dl-start.S
@@ -0,0 +1,104 @@
+/* Machine-dependent ELF startup code.  or1k version.
+   Copyright (C) 1995-2012 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <sysdep.h>
+
+/* Initial entry point code for the dynamic linker.
+   The C function `_dl_start' is the real entry point;
+   its return value is the user program's entry point. */
+ENTRY(_start)
+  /* Count arguments in r11 */
+  l.ori r3, r1, 0
+  l.movhi r11, 0
+1:
+  l.addi  r3, r3, 4
+  l.lwz r12, 0(r3)
+  l.sfnei r12, 0
+  l.addi  r11, r11, 1
+  l.bf  1b
+  l.nop
+  l.addi  r11, r11, -1
+  /* store argument counter to stack */
+  l.sw  0(r1), r11
+
+  l.jal .LPC0
+  l.nop
+  /* Load the PIC register */
+.LPC0:
+  l.movhi r16, gotpchi(_GLOBAL_OFFSET_TABLE_+(.-.LPC0))
+  l.ori r16, r16, gotpclo(_GLOBAL_OFFSET_TABLE_+(.-.LPC0))
+  l.add r16, r16, r9
+
+  l.ori r3, r1, 0
+
+  l.jal _dl_start
+  l.nop
+  /* Save user entry in a call saved reg */
+  l.ori r22, r11, 0
+  /* Fall through to _dl_start_user */
+
+_dl_start_user:
+
+  /* Set up for _dl_init. */
+
+  /* Load _rtld_local (a.k.a _dl_loaded) */
+  l.lwz r12, got(_rtld_local)(r16)
+  l.lwz r3, 0(r12)
+
+  /* Load argc */
+  l.lwz r18, got(_dl_argc)(r16)
+  l.lwz r4, 0(r18)
+
+  /* Load argv */
+  l.lwz r20, got(INTUSE(_dl_argv))(r16)
+  l.lwz r5, 0(r20)
+
+  /* Load envp = &argv[argc + 1] */
+  l.slli r6, r4, 2
+  l.addi r6, r6, 4
+  l.add r6, r6, r5
+
+  l.jal plt(_dl_init_internal)
+  l.nop
+
+  /* Now set up for user entry.
+     The already defined ABI loads argc and argv from the stack.
+
+     argc = 0(r1)
+     argv = r1 + 4
+
+     Also, uClibc code sets r9 to _dl_fini, so we continue to do so.
+  */
+
+  /* Load SP as argv - 4*/
+  l.lwz r3, 0(r20)
+  l.addi r1, r3, -4
+
+  /* Save argc */
+  l.lwz r3, 0(r18)
+  l.sw 0(r1), r3
+
+  /* Load termination function address */
+  l.movhi r9, gotoffhi(_dl_fini)
+  l.ori r9, r9, gotofflo(_dl_fini)
+  l.add r9, r9, r16
+
+  l.jr  r22
+  l.nop
+
+END(_start)
--- /dev/null
+++ eglibc-2.18/ports/sysdeps/or1k/crti.S
@@ -0,0 +1,74 @@
+# Start .init and .fini sections.
+# Copyright (C) 2010 Embecosm Limited
+# 
+# This file is free software; you can redistribute it and/or modify it
+# under the terms of the GNU General Public License as published by
+# the Free Software Foundation; either version 3, or (at your option)
+# any later version.
+# 
+# GCC is distributed in the hope that it will be useful, but WITHOUT ANY
+# WARRANTY; without even the implied warranty of MERCHANTABILITY or
+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
+# for more details.
+# 
+# Under Section 7 of GPL version 3, you are granted additional
+# permissions described in the GCC Runtime Library Exception, version
+# 3.1, as published by the Free Software Foundation.
+#
+# You should have received a copy of the GNU General Public License and
+# a copy of the GCC Runtime Library Exception along with this program;
+# see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see
+# <http://www.gnu.org/licenses/>.
+
+#include <libc-symbols.h>
+#include <sysdep.h>
+
+#ifndef PREINIT_FUNCTION
+# define PREINIT_FUNCTION __gmon_start__
+#endif
+
+#ifndef PREINIT_FUNCTION_WEAK
+# define PREINIT_FUNCTION_WEAK 1
+#endif
+
+#if PREINIT_FUNCTION_WEAK
+	weak_extern (PREINIT_FUNCTION)
+#else
+	.hidden PREINIT_FUNCTION
+#endif
+
+	.section .init
+	.global _init
+_init:
+	l.addi  r1,r1,-8
+	l.sw  0(r1),r9
+	l.sw  4(r1),r16
+
+#if PREINIT_FUNCTION_WEAK
+	l.jal 8
+
+	/* Check if PREINIT_FUNCTION is loaded in GOT */
+	l.movhi  r16,gotpchi(_GLOBAL_OFFSET_TABLE_-4)
+	l.ori    r16,r16,gotpclo(_GLOBAL_OFFSET_TABLE_+0)
+	l.add    r16,r16,r9
+	l.lwz    r9,got(PREINIT_FUNCTION)(r16)
+	l.sfeqi  r9,0
+	l.bf     .Lno_weak_fn
+	l.nop
+
+	l.jal    plt(PREINIT_FUNCTION)
+	l.nop
+
+.Lno_weak_fn:
+#else
+	l.jal PREINIT_FUNCTION
+	l.nop
+
+#endif
+
+	.section .fini
+	.global _fini
+_fini:
+	l.addi  r1,r1,-4
+	l.sw    0(r1),r9
+
--- /dev/null
+++ eglibc-2.18/ports/sysdeps/or1k/__longjmp.S
@@ -0,0 +1,75 @@
+/* longjmp for or1k
+
+   Based on:
+   longjmp for PowerPC.
+   Copyright (C) 1995, 1996, 1997, 1999, 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+#include <features.h>
+#define _ASM
+#define _SETJMP_H
+#include <bits/setjmp.h>
+
+.globl     __longjmp;
+.type      __longjmp,@function;
+.align     2;
+
+__longjmp:    
+  l.lwz   r1,((JB_GPRS+0)*4)(r3)
+  l.lwz   r2,((JB_GPRS+1)*4)(r3)
+
+  /* if r4 is 0, something wrong, so set it to 1 */
+  l.sfeqi r4, 0x0
+  l.bnf   1f /* r4 != 0, longjmp value sensible */
+  l.nop
+  l.ori   r4, r0, 0x1 /* make nonzero */
+1:
+  l.addi  r11, r4, 0
+  l.lwz   r4,((JB_GPRS+3)*4)(r3)
+  l.lwz   r5,((JB_GPRS+4)*4)(r3)
+  l.lwz   r6,((JB_GPRS+5)*4)(r3)
+  l.lwz   r7,((JB_GPRS+6)*4)(r3)
+  l.lwz   r8,((JB_GPRS+7)*4)(r3)
+  l.lwz   r9,((JB_GPRS+8)*4)(r3)
+  l.lwz   r10,((JB_GPRS+9)*4)(r3)
+  l.lwz   r12,((JB_GPRS+11)*4)(r3)
+  l.lwz   r13,((JB_GPRS+12)*4)(r3)
+  l.lwz   r14,((JB_GPRS+13)*4)(r3)
+  l.lwz   r15,((JB_GPRS+14)*4)(r3)
+  l.lwz   r16,((JB_GPRS+15)*4)(r3)
+  l.lwz   r17,((JB_GPRS+16)*4)(r3)
+  l.lwz   r18,((JB_GPRS+17)*4)(r3)
+  l.lwz   r19,((JB_GPRS+18)*4)(r3)
+  l.lwz   r20,((JB_GPRS+19)*4)(r3)
+  l.lwz   r21,((JB_GPRS+20)*4)(r3)
+  l.lwz   r22,((JB_GPRS+21)*4)(r3)
+  l.lwz   r23,((JB_GPRS+22)*4)(r3)
+  l.lwz   r24,((JB_GPRS+23)*4)(r3)
+  l.lwz   r25,((JB_GPRS+24)*4)(r3)
+  l.lwz   r26,((JB_GPRS+25)*4)(r3)
+  l.lwz   r27,((JB_GPRS+26)*4)(r3)
+  l.lwz   r28,((JB_GPRS+27)*4)(r3)
+  l.lwz   r29,((JB_GPRS+28)*4)(r3)
+  l.lwz   r30,((JB_GPRS+29)*4)(r3)
+  l.lwz   r31,((JB_GPRS+30)*4)(r3)
+  l.jr  r9
+  l.nop
+.size     __longjmp,.-__longjmp
+
+libc_hidden_def(__longjmp)
+
--- /dev/null
+++ eglibc-2.18/ports/sysdeps/or1k/jmpbuf-offsets.h
@@ -0,0 +1,23 @@
+/* Private macros for accessing __jmp_buf contents.  ARM EABI version.
+   Copyright (C) 2007 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#define __JMP_BUF_SP		1
+
+/* Helper for generic ____longjmp_chk(). */
+#define JB_FRAME_ADDRESS(buf) \
+    ((void *) (unsigned long) (buf[__JMP_BUF_SP]))
--- /dev/null
+++ eglibc-2.18/ports/sysdeps/or1k/start.S
@@ -0,0 +1,144 @@
+/* Copyright (C) 1995, 1996, 1997, 1998, 2001, 2002, 2005
+   Free Software Foundation, Inc.
+
+   Copyright (C) 2010 Embecosm Limited
+
+   Contributor  Jeremy Bennett <jeremy.bennett@embecosm.com>
+   Contributor  Joern Rennecke <joern.rennecke@embecosm.com>
+   With other contributions from the OpenCores community.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   In addition to the permissions in the GNU Lesser General Public
+   License, the Free Software Foundation gives you unlimited
+   permission to link the compiled version of this file with other
+   programs, and to distribute those programs without any restriction
+   coming from the use of this file. (The GNU Lesser General Public
+   License restrictions do apply in other respects; for example, they
+   cover modification of the file, and distribution when not linked
+   into another program.)
+
+   Note that people who make modified versions of this file are not
+   obligated to grant this special exception for their modified
+   versions; it is their choice whether to do so. The GNU Lesser
+   General Public License gives permission to release a modified
+   version without this exception; this exception also makes it
+   possible to release a modified version which carries forward this
+   exception.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* Stick in a dummy reference to main(), so that if an application
+ * is linking when the main() function is in a static library (.a)
+ * we can be sure that main() actually gets linked in */
+.type main,%function
+
+/* This is the canonical entry point, usually the first thing in the text
+   segment.
+
+   sp   The stack contains the arguments and environment:
+    0(sp)     argc
+    4(sp)     argv[0]
+    ...
+    (4*argc)(sp)    NULL
+    (4*(argc+1))(sp)  envp[0]
+    ...
+          NULL
+*/
+
+#include <features.h>
+
+.text
+  .globl  _start
+  .type _start,%function
+
+.global _start
+_start:
+
+#ifdef __PIC__
+  /* Obtain a pointer to .got in r16 */
+  l.jal .LPC0
+#ifndef __OR1K_NODELAY__
+  l.nop
+#endif
+.LPC0:
+  l.movhi r16, gotpchi(_GLOBAL_OFFSET_TABLE_+(.-.LPC0))
+  l.ori r16, r16, gotpclo(_GLOBAL_OFFSET_TABLE_+(.-.LPC0))
+  l.add r16, r16, r9
+#endif
+
+  /* Push stack limit onto the stack */
+  /* Provides highest stack address to user code (as stack grows
+   * downwards
+   * This is the seventh argument to __libc_start_main and thus needs to
+   * be passed on the stack
+   */
+  l.sw  -4(r1),r1
+
+  /* Take values for argc and argv off the stack.
+   * These will be passed as arguments two and three to __uClibc_main
+   * and thus go in registers r4 and r5, respectively
+   */
+  l.lwz  r4,0(r1)
+  l.addi r5,r1,4
+
+#ifdef __PIC__
+  l.lwz r3,got(main)(r16)
+#else
+  l.movhi r3,hi(main)
+  l.ori   r3,r3,lo(main)
+#endif
+
+  /* Put the constructor and destructor initialization as args four and
+     five into r6 and r7 */
+#ifdef __PIC__
+  l.lwz r6, got(__libc_csu_init)(r16)
+  l.lwz r7, got(__libc_csu_fini)(r16)
+#else
+  l.movhi r6,hi(__libc_csu_init)
+  l.ori r6,r6,lo(__libc_csu_init)
+  l.movhi r7,hi(__libc_csu_fini)
+  l.ori r7,r7,lo(__libc_csu_fini)
+#endif
+
+  /* rtld_fini = NULL */
+  l.movhi r8, 0
+
+  /* Adjust stack to account for a total of 7 args (i.e. the last one is
+     on the stack. */
+  l.addi  r1,r1,-4
+
+  /* Clear the frame pointer and link register since this is the
+   * outermost frame.
+   */
+  l.add r2,r0,r0
+  l.add r9,r0,r0
+
+  /* Let the libc call main and exit with its return code.  */
+#ifdef __PIC__
+  l.j plt(__libc_start_main)
+#else
+  l.j __libc_start_main
+#endif
+   l.nop
+
+/* Define a symbol for the first piece of initialized data.  */
+  .data
+  .globl __data_start
+__data_start:
+  .long 0
+  .weak data_start
+  data_start = __data_start
--- /dev/null
+++ eglibc-2.18/ports/sysdeps/or1k/libc-tls.c
@@ -0,0 +1,32 @@
+/* Copyright (C) 2005-2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <csu/libc-tls.c>
+#include <dl-tls.h>
+
+/* On AArch64, linker optimizations are not required, so __tls_get_addr
+   can be called even in statically linked binaries.  In this case module
+   must be always 1 and PT_TLS segment exist in the binary, otherwise it
+   would not link.  */
+
+void *
+__tls_get_addr (tls_index *ti)
+{
+  dtv_t *dtv = THREAD_DTV ();
+  return (char *) dtv[1].pointer.val + ti->ti_offset;
+}
--- /dev/null
+++ eglibc-2.18/ports/sysdeps/or1k/jmpbuf-unwind.h
@@ -0,0 +1,35 @@
+/* Copyright (C) 2005,2006 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#include <setjmp.h>
+#include <jmpbuf-offsets.h>
+#include <stdint.h>
+#include <unwind.h>
+
+/* Test if longjmp to JMPBUF would unwind the frame
+   containing a local variable at ADDRESS.  */
+#define _JMPBUF_UNWINDS(jmpbuf, address, demangle) \
+  ((void *) (address) < (void *) demangle (jmpbuf[__JMP_BUF_SP]))
+
+#define _JMPBUF_CFA_UNWINDS_ADJ(_jmpbuf, _context, _adj) \
+  _JMPBUF_UNWINDS_ADJ (_jmpbuf, (void *) _Unwind_GetCFA (_context), _adj)
+
+#define _JMPBUF_UNWINDS_ADJ(_jmpbuf, _address, _adj) \
+  ((uintptr_t) (_address) - (_adj) < (uintptr_t) (_jmpbuf)[__JMP_BUF_SP] - (_adj))
+
+/* We use the normal longjmp for unwinding.  */
+#define __libc_unwind_longjmp(buf, val) __libc_longjmp (buf, val)
--- /dev/null
+++ eglibc-2.18/ports/sysdeps/or1k/bsd-_setjmp.S
@@ -0,0 +1 @@
+/* _setjmp is in setjmp.S  */
--- /dev/null
+++ eglibc-2.18/ports/sysdeps/or1k/dl-machine.h
@@ -0,0 +1,317 @@
+/* Machine-dependent ELF dynamic relocation inline functions.  SH version.
+   Copyright (C) 1999-2012 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef dl_machine_h
+#define dl_machine_h
+
+#define ELF_MACHINE_NAME "or1k"
+
+#include <sys/param.h>
+#include <tls.h>
+#include <dl-irel.h>
+#include <assert.h>
+
+/* All relocs are Rela, no Rel */
+#define ELF_MACHINE_NO_REL 1
+
+/* Return nonzero iff ELF header is compatible with the running host.  */
+static inline int __attribute__ ((unused))
+elf_machine_matches_host (const Elf32_Ehdr *ehdr)
+{
+  return ehdr->e_machine == EM_OPENRISC;
+}
+
+static inline Elf32_Addr *
+or1k_get_got (void)
+{
+  Elf32_Addr *got;
+  Elf32_Addr linkreg;
+  __asm__("l.ori   %0, r9, 0\n"
+    "l.jal  8\n"
+    "l.movhi  %1, gotpchi(_GLOBAL_OFFSET_TABLE_-4)\n"
+    "l.ori  %1, %1, gotpclo(_GLOBAL_OFFSET_TABLE_+0)\n"
+    "l.add  %1, %1, r9\n"
+    "l.ori  r9, %0, 0\n"
+    : "=r" (linkreg), "=r" (got));
+
+  return got;
+}
+
+/* Return the link-time address of _DYNAMIC.  Conveniently, this is the
+   first element of the GOT. */
+static inline Elf32_Addr
+elf_machine_dynamic (void)
+{
+  Elf32_Addr *got = or1k_get_got();
+  return *got;
+}
+
+
+/* Return the run-time load address of the shared object.  */
+static inline Elf32_Addr
+elf_machine_load_address (void)
+{
+  /* Compute the difference between the runtime address of _DYNAMIC as seen
+     by a GOTOFF reference, and the link-time address found in the special
+     unrelocated first GOT entry.  */
+  Elf32_Addr dyn;
+  Elf32_Addr *got = or1k_get_got();
+
+  __asm__ __volatile__ (
+    "l.movhi %0, gotoffhi(_DYNAMIC);"
+    "l.ori %0, %0, gotofflo(_DYNAMIC);"
+    "l.add %0, %0, %1;"
+    : "=r"(dyn) : "r"(got)
+    );
+
+  return dyn - *got;
+}
+
+/* Initial entry point code for the dynamic linker.
+   The C function `_dl_start' is the real entry point;
+   its return value is the user program's entry point.
+
+   Code is really located in dl-start.S, just tell the
+   linker that it exists. */
+#define RTLD_START asm (".globl _dl_start");
+
+/* ELF_RTYPE_CLASS_PLT iff TYPE describes relocation of a PLT entry or
+   TLS variable, so undefined references should not be allowed to
+   define the value.
+   ELF_RTYPE_CLASS_NOCOPY iff TYPE should not be allowed to resolve to one
+   of the main executable's symbols, as for a COPY reloc.  */
+
+#define elf_machine_type_class(type) \
+  (((type) == R_OR1K_JMP_SLOT \
+   || (type) == R_OR1K_TLS_DTPMOD \
+   || (type) == R_OR1K_TLS_DTPOFF \
+   || (type) == R_OR1K_TLS_TPOFF) * ELF_RTYPE_CLASS_PLT \
+   | ((type) == R_OR1K_COPY) * ELF_RTYPE_CLASS_COPY)
+
+/* A reloc type used for ld.so cmdline arg lookups to reject PLT entries.  */
+#define ELF_MACHINE_JMP_SLOT    R_OR1K_JMP_SLOT
+
+#define ARCH_LA_PLTENTER or1k_gnu_pltenter
+#define ARCH_LA_PLTEXIT or1k_gnu_pltexit
+
+/* Set up the loaded object described by L so its unrelocated PLT
+   entries will jump to the on-demand fixup code in dl-runtime.c.  */
+static inline int __attribute__ ((unused, always_inline))
+elf_machine_runtime_setup (struct link_map *l, int lazy, int profile)
+{
+  ElfW(Addr) *gotplt;
+  extern void _dl_runtime_resolve (ElfW(Word));
+  extern void _dl_runtime_profile (ElfW(Word));
+
+  /* We do not support profiling yet */
+  assert(profile == 0);
+
+  if (l->l_info[DT_JMPREL] && lazy)
+    {
+      gotplt = (ElfW(Addr) *) D_PTR (l, l_info[DT_PLTGOT]);
+
+      /* Fill in the got */
+
+      /* Register our address in the got.
+       * This will also be used in the resolver for accessing the
+       * link_map structure. */
+      gotplt[1] = (ElfW(Addr)) l;
+
+      /* This function will get called to fix up the GOTPLT entry
+         indicated by the offset on the stack, and then jump to the
+         resolved address.  */
+      gotplt[2] = (ElfW(Addr)) &_dl_runtime_resolve;
+
+    }
+
+  return lazy;
+}
+
+/* Mask identifying addresses reserved for the user program,
+   where the dynamic linker should not map anything.  */
+#define ELF_MACHINE_USER_ADDRESS_MASK   0xf8000000UL
+
+/* We define an initialization functions.  This is called very early in
+   _dl_sysdep_start.  */
+#define DL_PLATFORM_INIT dl_platform_init ()
+
+static inline void __attribute__ ((unused))
+dl_platform_init (void)
+{
+  if (GLRO(dl_platform) != NULL && *GLRO(dl_platform) == '\0')
+    /* Avoid an empty string which would disturb us.  */
+    GLRO(dl_platform) = NULL;
+}
+
+static inline Elf32_Addr
+elf_machine_fixup_plt (struct link_map *map, lookup_t t,
+                       const Elf32_Rela *reloc,
+                       Elf32_Addr *reloc_addr, Elf32_Addr value)
+{
+  return *reloc_addr = value;
+}
+
+/* Return the final value of a plt relocation.  */
+static inline Elf32_Addr
+elf_machine_plt_value (struct link_map *map, const Elf32_Rela *reloc,
+                       Elf32_Addr value)
+{
+  return value + reloc->r_addend;
+}
+
+
+#endif /* !dl_machine_h */
+
+#ifdef RESOLVE_MAP
+
+/* Perform the relocation specified by RELOC and SYM (which is fully resolved).
+   MAP is the object containing the reloc.  */
+
+auto inline void
+__attribute ((always_inline))
+elf_machine_rela (struct link_map *map, const Elf32_Rela *reloc,
+                  const Elf32_Sym *sym, const struct r_found_version *version,
+                  void *const reloc_addr_arg, int skip_ifunc)
+{
+  Elf32_Addr *const reloc_addr = reloc_addr_arg;
+  const unsigned int r_type = ELF32_R_TYPE (reloc->r_info);
+
+  if (__builtin_expect (r_type == R_OR1K_NONE, 0))
+    return;
+  else
+    {
+# ifndef RESOLVE_CONFLICT_FIND_MAP
+      const Elf32_Sym *const refsym = sym;
+# endif
+      struct link_map *sym_map = RESOLVE_MAP (&sym, version, r_type);
+      Elf32_Addr value = sym_map == NULL ? 0 : sym_map->l_addr + sym->st_value;
+
+      if (sym != NULL
+          && __builtin_expect (ELFW(ST_TYPE) (sym->st_info) == STT_GNU_IFUNC, 0)
+          && __builtin_expect (sym->st_shndx != SHN_UNDEF, 1)
+          && __builtin_expect (!skip_ifunc, 1))
+        value = elf_ifunc_invoke (value);
+
+      switch (r_type)
+        {
+# ifndef RESOLVE_CONFLICT_FIND_MAP
+          case R_OR1K_COPY:
+            if (sym == NULL)
+              /* This can happen in trace mode if an object could not be
+                 found.  */
+              break;
+            if (__builtin_expect (sym->st_size > refsym->st_size, 0)
+                || (__builtin_expect (sym->st_size < refsym->st_size, 0)
+                  && GLRO(dl_verbose)))
+            {
+              const char *strtab;
+
+              strtab = (const char *) D_PTR (map, l_info[DT_STRTAB]);
+              _dl_error_printf ("\
+%s: Symbol `%s' has different size in shared object, consider re-linking\n",
+                  rtld_progname ?: "<program name unknown>",
+                  strtab + refsym->st_name);
+            }
+            memcpy (reloc_addr_arg, (void *) value,
+                MIN (sym->st_size, refsym->st_size));
+            break;
+#endif
+          case R_OR1K_32:
+	    {
+	      /* Handle mis-aligned offsets */
+	      struct unaligned
+		{
+		  Elf32_Addr x;
+		} __attribute__ ((packed, may_alias));
+
+	      /* Support relocations on mis-aligned offsets.  */
+	      ((struct unaligned *) reloc_addr)->x = value + reloc->r_addend;
+	      break;
+	    }
+	  case R_OR1K_INSN_REL_26:
+	  case R_OR1K_GLOB_DAT:
+	  case R_OR1K_JMP_SLOT:
+	    *reloc_addr = value + reloc->r_addend;
+	    break;
+	  case R_OR1K_TLS_DTPMOD:
+# ifdef RTLD_BOOTSTRAP
+	    /* During startup the dynamic linker is always the module
+	       with index 1. */
+	    *reloc_addr = 1;
+# else
+	    if (sym_map != NULL)
+	      *reloc_addr = sym_map->l_tls_modid;
+# endif
+	    break;
+	  case R_OR1K_TLS_DTPOFF:
+# ifndef RTLD_BOOTSTRAP
+	    *reloc_addr = (sym == NULL ? 0 : sym->st_value) + reloc->r_addend;
+# endif
+	    break;
+
+          case R_OR1K_TLS_TPOFF:
+# ifdef RTLD_BOOTSTRAP
+	    *reloc_addr = sym->st_value + reloc->r_addend +
+	      map->l_tls_offset - TLS_TCB_SIZE;
+# else
+	    if (sym_map != NULL)
+	      {
+		CHECK_STATIC_TLS (map, sym_map);
+		*reloc_addr = sym->st_value + reloc->r_addend +
+		  sym_map->l_tls_offset - TLS_TCB_SIZE;
+	      }
+# endif
+	    break;
+          default:
+            _dl_fatal_printf("Unhandled reloc: %u\n", r_type);
+            _dl_reloc_bad_type (map, r_type, 0);
+            break;
+        }
+    }
+}
+
+auto inline void
+__attribute__ ((always_inline))
+elf_machine_rela_relative (Elf32_Addr l_addr, const Elf32_Rela *reloc,
+                           void *const reloc_addr_arg)
+{
+  Elf32_Addr *const reloc_addr = reloc_addr_arg;
+  *reloc_addr = l_addr + reloc->r_addend;
+}
+
+auto inline void
+__attribute__ ((always_inline))
+elf_machine_lazy_rel (struct link_map *map,
+                      Elf32_Addr l_addr, const Elf32_Rela *reloc,
+                      int skip_ifunc)
+{
+  Elf32_Addr *const reloc_addr = (void *) (l_addr + reloc->r_offset);
+  const unsigned int r_type = ELF32_R_TYPE (reloc->r_info);
+
+  if (__builtin_expect (r_type == R_OR1K_JMP_SLOT, 1))
+      *reloc_addr += l_addr;
+  else if (__builtin_expect (r_type == R_OR1K_NONE, 0))
+    return;
+  else
+    {
+      _dl_fatal_printf("Unhandled lazy reloc: %u\n", r_type);
+      _dl_reloc_bad_type (map, r_type, 1);
+    }
+}
+
+#endif /* RESOLVE_MAP */
--- /dev/null
+++ eglibc-2.18/ports/sysdeps/or1k/Implies
@@ -0,0 +1,3 @@
+wordsize-32
+ieee754/flt-32
+ieee754/dbl-64
--- /dev/null
+++ eglibc-2.18/ports/sysdeps/or1k/bits/fenv.h
@@ -0,0 +1,74 @@
+/* Copyright (C) 2004-2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _FENV_H
+# error "Never use <bits/fenv.h> directly; include <fenv.h> instead."
+#endif
+
+/* Define bits representing exceptions in the FPSR status word.  */
+enum
+  {
+    FE_INVALID =
+#define FE_INVALID	1
+      FE_INVALID,
+    FE_DIVBYZERO =
+#define FE_DIVBYZERO	2
+      FE_DIVBYZERO,
+    FE_OVERFLOW =
+#define FE_OVERFLOW	4
+      FE_OVERFLOW,
+    FE_UNDERFLOW =
+#define FE_UNDERFLOW	8
+      FE_UNDERFLOW,
+    FE_INEXACT =
+#define FE_INEXACT	16
+      FE_INEXACT,
+  };
+
+/* Amount to shift by to convert an exception bit in FPSR to a an
+   exception bit mask in FPCR.  */
+#define FE_EXCEPT_SHIFT	8
+
+/* All supported exceptions.  */
+#define FE_ALL_EXCEPT	\
+	(FE_INVALID | FE_DIVBYZERO | FE_OVERFLOW | FE_UNDERFLOW | FE_INEXACT)
+
+/* Define bits representing rounding modes in the FPCR Rmode field.  */
+#define FE_TONEAREST  0x000000
+#define FE_UPWARD     0x400000
+#define FE_DOWNWARD   0x800000
+#define FE_TOWARDZERO 0xc00000
+
+/* Type representing exception flags. */
+typedef unsigned int fexcept_t;
+
+/* Type representing floating-point environment.  */
+typedef struct
+  {
+    unsigned int __fpcr;
+    unsigned int __fpsr;
+  }
+fenv_t;
+
+/* If the default argument is used we use this value.  */
+#define FE_DFL_ENV	((const fenv_t *) -1l)
+
+#ifdef __USE_GNU
+/* Floating-point environment where none of the exceptions are masked.  */
+# define FE_NOMASK_ENV  ((const fenv_t *) -2)
+#endif
--- /dev/null
+++ eglibc-2.18/ports/sysdeps/or1k/bits/endian.h
@@ -0,0 +1,30 @@
+/*
+ * This is free and unencumbered software released into the public domain.
+ *
+ * Anyone is free to copy, modify, publish, use, compile, sell, or
+ * distribute this software, either in source code form or as a compiled
+ * binary, for any purpose, commercial or non-commercial, and by any
+ * means.
+ *
+ * In jurisdictions that recognize copyright laws, the author or authors
+ * of this software dedicate any and all copyright interest in the
+ * software to the public domain. We make this dedication for the benefit
+ * of the public at large and to the detriment of our heirs and
+ * successors. We intend this dedication to be an overt act of
+ * relinquishment in perpetuity of all present and future rights to this
+ * software under copyright law.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
+ * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
+ * MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
+ * IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
+ * OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
+ * ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
+ * OTHER DEALINGS IN THE SOFTWARE.
+ */
+
+#ifndef _ENDIAN_H
+# error "Never use <bits/endian.h> directly; include <endian.h> instead."
+#endif
+
+#define __BYTE_ORDER __BIG_ENDIAN
--- /dev/null
+++ eglibc-2.18/ports/sysdeps/or1k/bits/setjmp.h
@@ -0,0 +1,47 @@
+/* Copyright (C) 1997, 1998, 2000 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, write to the Free
+   Software Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA
+   02111-1307 USA.  */
+
+/* Define the machine-dependent type `jmp_buf'.  or1k version.  */
+
+#ifndef _BITS_SETJMP_H
+#define _BITS_SETJMP_H  1
+
+#if !defined _SETJMP_H && !defined _PTHREAD_H
+# error "Never include <bits/setjmp.h> directly; use <setjmp.h> instead."
+#endif
+
+#if defined __USE_MISC || defined _ASM
+# define JB_SR     0  /* To save flag */
+# define JB_GPRS   1  /* Starting with GPR1, we don't save r0 - this is special register - allways zero */
+# define JB_SP     1  /* GPR1 */
+# define JB_LR     9  /* GPR9 */
+# define JB_RV     11 /* GPR11 */
+# define JB_SIZE   (32*4)
+#endif
+
+#ifndef _ASM
+typedef long int __jmp_buf[32];
+#endif
+
+/* Test if longjmp to JMPBUF would unwind the frame
+   containing a local variable at ADDRESS.  */
+#define _JMPBUF_UNWINDS(jmpbuf, address) \
+  ((void *) (address) < (void *) (jmpbuf)[JB_SP])
+
+#endif
+
--- /dev/null
+++ eglibc-2.18/ports/sysdeps/or1k/nptl/Makefile
@@ -0,0 +1,21 @@
+# Copyright (C) 2005-2012 Free Software Foundation, Inc.
+#
+# This file is part of the GNU C Library.
+#
+# The GNU C Library is free software; you can redistribute it and/or
+# modify it under the terms of the GNU Lesser General Public
+# License as published by the Free Software Foundation; either
+# version 2.1 of the License, or (at your option) any later version.
+#
+# The GNU C Library is distributed in the hope that it will be useful,
+# but WITHOUT ANY WARRANTY; without even the implied warranty of
+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+# Lesser General Public License for more details.
+#
+# You should have received a copy of the GNU Lesser General Public
+# License along with the GNU C Library.  If not, see
+# <http://www.gnu.org/licenses/>.
+
+ifeq ($(subdir),csu)
+gen-as-const-headers += tcb-offsets.sym
+endif
--- /dev/null
+++ eglibc-2.18/ports/sysdeps/or1k/nptl/tls.h
@@ -0,0 +1,197 @@
+/* Definition for thread-local data handling.  NPTL/ARM version.
+   Copyright (C) 2005, 2007, 2011 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _TLS_H
+#define _TLS_H  1
+
+#include <dl-sysdep.h>
+
+#ifndef __ASSEMBLER__
+# include <stdbool.h>
+# include <stddef.h>
+# include <stdint.h>
+
+/* Type for the dtv.  */
+typedef union dtv
+{
+  size_t counter;
+  struct
+  {
+    void *val;
+    bool is_static;
+  } pointer;
+} dtv_t;
+
+typedef struct
+{
+  /* TODO: uintptr_t pointer_guard;
+   * TODO: uintptr_t stack_guard; */
+  dtv_t *dtv;
+} tcbhead_t;
+
+register tcbhead_t *__thread_self __asm__("r10");
+
+# define TLS_MULTIPLE_THREADS_IN_TCB 1
+
+#else /* __ASSEMBLER__ */
+# include <tcb-offsets.h>
+#endif /* __ASSEMBLER__ */
+
+#ifndef __ASSEMBLER__
+
+/* Get system call information.  */
+# include <sysdep.h>
+
+/* The TP points to the start of the TLS block.
+ * As I understand it, this isn't strictly that "TP points to DTV" - it's
+ * more where to place the TCB in the TLS block. This will place it in 
+ * the beginning.
+ *
+ * Layout:
+ *  ------------------------------------
+ *  | PRE | TCB | TLS MEMORY ..        |
+ *  ------------------------------------
+ *              ^ r10 / TP
+ *
+ * PRE is the struct pthread described below
+ * TCB is tcbhead_t
+ * TLS memory is where the TLS program sections are loaded
+ *
+ * See _dl_allocate_tls_storage and __libc_setup_tls for more information.
+ */
+# define TLS_DTV_AT_TP  1
+
+/* Get the thread descriptor definition.  */
+# include <nptl/descr.h>
+
+/* Requirements for the TCB.  */
+# define TLS_INIT_TCB_SIZE    sizeof (tcbhead_t)
+# define TLS_INIT_TCB_ALIGN   __alignof__ (tcbhead_t)
+
+# define TLS_TCB_SIZE         sizeof (tcbhead_t)
+# define TLS_TCB_ALIGN        __alignof__ (tcbhead_t)
+
+/* This is the size of the TCB.  */
+
+/* This is the size we need before TCB.
+ * To support THREAD_GETMEM with friends we want to have a
+ * struct pthread available.
+ * Yank it in infront of everything, I'm sure nobody will mind.
+ *
+ * This memory is really allocated PRE the TLS block, so it's possible
+ * to do ((char*)tlsblock) - TLS_PRE_TCB_SIZE to access it.
+ * This is done for THREAD_SELF. */
+# define TLS_PRE_TCB_SIZE sizeof (struct pthread)
+
+
+/* Install the dtv pointer.
+ * When called, dtvp is a pointer not the DTV per say (which should start
+ * with the generation counter) but to the length of the DTV.
+ * We can always index with -1, so we store dtvp[1]
+ */
+# define INSTALL_DTV(tcbp, dtvp) \
+  (((tcbhead_t *) (tcbp))->dtv = (dtvp) + 1)
+
+/* Install new dtv for current thread
+ * In a logicial world dtv here would also point to the length of the DTV.
+ * However it does not, this time it points to the generation counter,
+ * so just store it.
+ *
+ * Note: -1 is still valid and contains the length. */
+# define INSTALL_NEW_DTV(dtv) \
+  (THREAD_DTV() = (dtv))
+
+/* Return dtv of given thread descriptor.  */
+# define GET_DTV(tcbp) \
+  (((tcbhead_t *) (tcbp))->dtv)
+
+/* Code to initially initialize the thread pointer.
+ *
+ * Set TP to the address _after_ tcbhead_t. This will allow us
+ * to change the size of tcbhead_t without having to re-link everything.
+ *
+ * secondcall has something to do with USE__THREAD,
+ * seems to always be 0 so we don't care about it.
+ *
+ * This has to return NULL on success (or a string with the failure text).
+ * It's hard to fail this, so return NULL always.
+ */
+# define TLS_INIT_TP(tcbp, secondcall) \
+  ({__thread_self = ((tcbhead_t *)tcbp + 1); NULL;})
+
+/* Return the address of the dtv for the current thread.
+ *
+ * Dereference TP, offset to dtv - really straightforward.
+ * Remember that we made TP point to after tcb, so we need to reverse that.
+ */
+#  define THREAD_DTV() \
+  ((((tcbhead_t *)__thread_self)-1)->dtv)
+
+/* Return the thread descriptor for the current thread. 
+ *
+ * Return a pointer to the TLS_PRE area where we allocated space for
+ * a struct pthread. Again, TP points to after tcbhead_t, compensate with
+ * TLS_INIT_TCB_SIZE.
+ *
+ * I regard this is a seperate system from the "normal" TLS.
+ */
+# define THREAD_SELF \
+  ((struct pthread *) ((char *) __thread_self - TLS_INIT_TCB_SIZE \
+    - TLS_PRE_TCB_SIZE))
+
+/* Magic for libthread_db to know how to do THREAD_SELF.  */
+# define DB_THREAD_SELF \
+  CONST_THREAD_AREA (32, sizeof (struct pthread))
+
+/* Access to data in the thread descriptor is easy.  */
+#define THREAD_GETMEM(descr, member) \
+  descr->member
+#define THREAD_GETMEM_NC(descr, member, idx) \
+  descr->member[idx]
+#define THREAD_SETMEM(descr, member, value) \
+  descr->member = (value)
+#define THREAD_SETMEM_NC(descr, member, idx, value) \
+  descr->member[idx] = (value)
+
+/* Get and set the global scope generation counter in struct pthread.  */
+#define THREAD_GSCOPE_FLAG_UNUSED 0
+#define THREAD_GSCOPE_FLAG_USED   1
+#define THREAD_GSCOPE_FLAG_WAIT   2
+#define THREAD_GSCOPE_RESET_FLAG() \
+  do                       \
+    { int __res                    \
+  = atomic_exchange_rel (&THREAD_SELF->header.gscope_flag,       \
+             THREAD_GSCOPE_FLAG_UNUSED);         \
+      if (__res == THREAD_GSCOPE_FLAG_WAIT)            \
+  lll_futex_wake (&THREAD_SELF->header.gscope_flag, 1, LLL_PRIVATE);   \
+    }                      \
+  while (0)
+#define THREAD_GSCOPE_SET_FLAG() \
+  do                       \
+    {                      \
+      THREAD_SELF->header.gscope_flag = THREAD_GSCOPE_FLAG_USED;       \
+      atomic_write_barrier ();                 \
+    }                      \
+  while (0)
+#define THREAD_GSCOPE_WAIT() \
+  GL(dl_wait_lookup_done) ()
+
+#endif /* __ASSEMBLER__ */
+
+#endif  /* tls.h */
+
--- /dev/null
+++ eglibc-2.18/ports/sysdeps/or1k/nptl/pthreaddef.h
@@ -0,0 +1,38 @@
+/* Copyright (C) 2002-2012 Free Software Foundation, Inc.
+
+   This file is part of the GNU C Library.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public License as
+   published by the Free Software Foundation; either version 2.1 of the
+   License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library; if not, see
+   <http://www.gnu.org/licenses/>.  */
+
+/* Default stack size.  */
+#define ARCH_STACK_DEFAULT_SIZE (2 * 1024 * 1024)
+
+/* Required stack pointer alignment at beginning.  */
+#define STACK_ALIGN 16
+
+/* Minimal stack size after allocating thread descriptor and guard size.  */
+#define MINIMAL_REST_STACK 2048
+
+/* Alignment requirement for TCB.  */
+#define TCB_ALIGNMENT 16
+
+/* Location of current stack frame.  */
+#define CURRENT_STACK_FRAME __builtin_frame_address (0)
+
+
+/* XXX Until we have a better place keep the definitions here.  */
+#define __exit_thread_inline(val) \
+  INLINE_SYSCALL (exit, 1, (val))
+
--- /dev/null
+++ eglibc-2.18/ports/sysdeps/or1k/nptl/tcb-offsets.sym
@@ -0,0 +1,9 @@
+#include <sysdep.h>
+#include <tls.h>
+
+PTHREAD_MULTIPLE_THREADS_OFFSET		offsetof (struct pthread, header.multiple_threads)
+PTHREAD_PID_OFFSET			offsetof (struct pthread, pid)
+PTHREAD_TID_OFFSET			offsetof (struct pthread, tid)
+PTHREAD_SIZEOF				sizeof (struct pthread)
+TCB_SIZEOF				sizeof (tcbhead_t)
+TP_TO_PTHREAD_OFFSET			-(sizeof (struct pthread) + sizeof (tcbhead_t))
--- /dev/null
+++ eglibc-2.18/ports/sysdeps/unix/sysv/linux/or1k/nptl/bits/atomic.h
@@ -0,0 +1,128 @@
+/* Copyright (C) 2010-2012 Free Software Foundation, Inc.
+   This file is part of the GNU C Library.
+   Contributed by Maxim Kuvyrkov <maxim@codesourcery.com>, 2010.
+
+   The GNU C Library is free software; you can redistribute it and/or
+   modify it under the terms of the GNU Lesser General Public
+   License as published by the Free Software Foundation; either
+   version 2.1 of the License, or (at your option) any later version.
+
+   The GNU C Library is distributed in the hope that it will be useful,
+   but WITHOUT ANY WARRANTY; without even the implied warranty of
+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+   Lesser General Public License for more details.
+
+   You should have received a copy of the GNU Lesser General Public
+   License along with the GNU C Library.  If not, see
+   <http://www.gnu.org/licenses/>.  */
+
+#ifndef _BITS_ATOMIC_H
+#define _BITS_ATOMIC_H	1
+
+#include <stdint.h>
+
+/* This is needed to break a depencency loop, we do not need errno anyway */
+#ifndef _ERRNO_H
+# define _ERRNO_H
+# include <sysdep.h>
+# undef _ERRNO_H
+#else
+# include <sysdep.h>
+#endif
+
+/* Or1k has no atomic compare-and-exchange operation, but the
+   kernel provides userspace atomicity operations.  Use them.  */
+
+typedef int32_t atomic32_t;
+typedef uint32_t uatomic32_t;
+typedef int_fast32_t atomic_fast32_t;
+typedef uint_fast32_t uatomic_fast32_t;
+
+typedef intptr_t atomicptr_t;
+typedef uintptr_t uatomicptr_t;
+typedef intmax_t atomic_max_t;
+typedef uintmax_t uatomic_max_t;
+
+/* TODO: Move these to a kernel header */
+#define OR1K_ATOMIC_SWAP	1
+#define OR1K_ATOMIC_CMPXCHG	2
+#define OR1K_ATOMIC_XCHG	3
+#define OR1K_ATOMIC_ADD		4
+#define OR1K_ATOMIC_DECPOS	5
+#define OR1K_ATOMIC_AND		6
+#define OR1K_ATOMIC_OR		7
+#define OR1K_ATOMIC_UMAX	8
+#define OR1K_ATOMIC_UMIN	9
+
+#define atomic_compare_and_exchange_val_acq(mem, newval, oldval) \
+  ((__typeof (*(mem))) ((sizeof (*(mem)) == 4) ? \
+	 INTERNAL_SYSCALL (or1k_atomic, , 4, \
+	    OR1K_ATOMIC_CMPXCHG, mem, oldval, newval) \
+	 : __atomic_error_bad_argument_size ()))
+
+#define atomic_exchange_acq(mem, newval) \
+  ((__typeof (*(mem))) ((sizeof (*(mem)) == 4) ? \
+	 INTERNAL_SYSCALL (or1k_atomic, , 3, \
+	    OR1K_ATOMIC_XCHG, mem, newval) \
+	 : __atomic_error_bad_argument_size ()))
+
+#define atomic_exchange_and_add_acq(mem, val) \
+  ((__typeof (*(mem))) ((sizeof (*(mem)) == 4) ? \
+	 INTERNAL_SYSCALL (or1k_atomic, , 3, \
+	    OR1K_ATOMIC_ADD, mem, val) \
+	 : __atomic_error_bad_argument_size ()))
+
+#define atomic_decrement_if_positive(mem) \
+  ((__typeof (*(mem))) ((sizeof (*(mem)) == 4) ? \
+	 INTERNAL_SYSCALL (or1k_atomic, , 2, \
+	    OR1K_ATOMIC_DECPOS, mem) \
+	 : __atomic_error_bad_argument_size ()))
+
+#define atomic_and_val(mem, mask) \
+  ((__typeof (*(mem))) ((sizeof (*(mem)) == 4) ? \
+	 INTERNAL_SYSCALL (or1k_atomic, , 3, \
+	    OR1K_ATOMIC_AND, mem, mask) \
+	 : __atomic_error_bad_argument_size ()))
+
+#define atomic_or_val(mem, mask) \
+  ((__typeof (*(mem))) ((sizeof (*(mem)) == 4) ? \
+	 INTERNAL_SYSCALL (or1k_atomic, , 3, \
+	    OR1K_ATOMIC_OR, mem, mask) \
+	 : __atomic_error_bad_argument_size ()))
+
+#define atomic_max_val(mem, val) \
+  ((__typeof (*(mem))) ((sizeof (*(mem)) == 4) ? \
+	 INTERNAL_SYSCALL (or1k_atomic, , 3, \
+	    OR1K_ATOMIC_UMAX, mem, val) \
+	 : __atomic_error_bad_argument_size ()))
+
+#define atomic_min_val(mem, val) \
+  ((__typeof (*(mem))) ((sizeof (*(mem)) == 4) ? \
+	 INTERNAL_SYSCALL (or1k_atomic, , 3, \
+	    OR1K_ATOMIC_UMIN, mem, val) \
+	 : __atomic_error_bad_argument_size ()))
+
+
+/* atomic_bit_test_set in terms of atomic_or_val. */
+#define atomic_bit_test_set(mem, bit)                                    \
+    ({ __typeof (*(mem)) __att0_mask = ((__typeof (*(mem))) 1 << (bit)); \
+         atomic_or_val ((mem), __att0_mask) & __att0_mask; })
+
+/* Various macros that should just be synonyms. */
+#define catomic_exchange_and_add atomic_exchange_and_add
+#define atomic_and(mem, mask) ((void) atomic_and_val ((mem), (mask)))
+#define catomic_and atomic_and
+#define atomic_or(mem, mask) ((void) atomic_or_val ((mem), (mask)))
+#define catomic_or atomic_or
+#define atomic_max(mem, val) ((void)atomic_max_val ((mem), (val)))
+#define catomic_max atomic_max
+#define atomic_min(mem, val) ((void)atomic_min_val ((mem), (val)))
+#define catomic_min atomic_min
+/*
+ * This non-existent symbol is called for unsupporrted sizes,
+ * indicating a bug in the caller.
+ */
+extern int __atomic_error_bad_argument_size(void)
+    __attribute__ ((error ("bad sizeof atomic argument")));
+
+#endif
